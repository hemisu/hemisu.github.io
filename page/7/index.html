<!DOCTYPE html>
<html lang="zh-CN,en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.hemisu.com","root":"/","scheme":"Gemini","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="Just do...">
<meta property="og:type" content="website">
<meta property="og:title" content="何米酥&#96;s Blog">
<meta property="og:url" content="http://www.hemisu.com/page/7/index.html">
<meta property="og:site_name" content="何米酥&#96;s Blog">
<meta property="og:description" content="Just do...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="何米酥">
<meta property="article:tag" content="web, 前端, 生活, 分享">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.hemisu.com/page/7/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>何米酥`s Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">何米酥`s Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">EFE</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">何米酥</p>
  <div class="site-description" itemprop="description">Just do...</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">203</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hemisu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hemisu" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/hemisu" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;hemisu" rel="noopener" target="_blank"><i class="globe fa-fw"></i>知乎</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/25/231/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/25/231/" class="post-title-link" itemprop="url">PAT A1018</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-02-25 16:28:31" itemprop="dateCreated datePublished" datetime="2017-02-25T16:28:31+00:00">2017-02-25</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2017-02-26 10:50:15" itemprop="dateModified" datetime="2017-02-26T10:50:15+00:00">2017-02-26</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>There is a public bike service in Hangzhou City which provides great convenience to the tourists from all over the world. One may rent a bike at any station and return it to any other stations in the city.</p>
<p>The Public Bike Management Center (PBMC) keeps monitoring the real-time capacity of all the stations. A station is said to be in perfect condition if it is exactly half-full. If a station is full or empty, PBMC will collect or send bikes to adjust the condition of that station to perfect. And more, all the stations on the way will be adjusted as well.</p>
<p>When a problem station is reported, PBMC will always choose the shortest path to reach that station. If there are more than one shortest path, the one that requires the least number of bikes sent from PBMC will be chosen.<br><img data-src="https://www.patest.cn/upload/11_lrrk0m5o4kg.jpg" alt="请输入图片描述"></p>
<p>Figure 1<br>Figure 1 illustrates an example. The stations are represented by vertices and the roads correspond to the edges. The number on an edge is the time taken to reach one end station from another. The number written inside a vertex S is the current number of bikes stored at S. Given that the maximum capacity of each station is 10. To solve the problem at S3, we have 2 different shortest paths:</p>
<ol>
<li><p>PBMC -&gt; S1 -&gt; S3. In this case, 4 bikes must be sent from PBMC, because we can collect 1 bike from S1 and then take 5 bikes to S3, so that both stations will be in perfect conditions.</p>
</li>
<li><p>PBMC -&gt; S2 -&gt; S3. This path requires the same time as path 1, but only 3 bikes sent from PBMC and hence is the one that will be chosen.</p>
</li>
</ol>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains 4 numbers: Cmax (&lt;= 100), always an even number, is the maximum capacity of each station; N (&lt;= 500), the total number of stations; Sp, the index of the problem station (the stations are numbered from 1 to N, and PBMC is represented by the vertex 0); and M, the number of roads. The second line contains N non-negative numbers Ci (i=1,…N) where each Ci is the current number of bikes at Si respectively. Then M lines follow, each contains 3 numbers: Si, Sj, and Tij which describe the time Tij taken to move betwen stations Si and Sj. All the numbers in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each test case, print your results in one line. First output the number of bikes that PBMC must send. Then after one space, output the path in the format: 0-&gt;S1-&gt;…-&gt;Sp. Finally after another space, output the number of bikes that we must take back to PBMC after the condition of Sp is adjusted to perfect.</p>
<p>Note that if such a path is not unique, output the one that requires minimum number of bikes that we must take back to PBMC. The judge’s data guarantee that such a path is unique.</p>
<p>Sample Input:<br>10 3 3 5<br>6 7 0<br>0 1 1<br>0 2 1<br>0 3 3<br>1 3 1<br>2 3 1<br>Sample Output:<br>3 0-&gt;2-&gt;3 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &quot;set&quot;</span><br><span class="line">#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXV &#x3D; 510;&#x2F;&#x2F;最大顶点数</span><br><span class="line">const int INF &#x3D; 1000000000;&#x2F;&#x2F;无穷大</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;n为顶点数，m为边数，Cmax为最大容量，Sp为问题站点</span><br><span class="line">&#x2F;&#x2F;G为邻接矩阵，weight为点权，d[]记录最短距离</span><br><span class="line">&#x2F;&#x2F;mindNeed记录最少携带数目，minRemain记录最少带回的数目</span><br><span class="line">int n, m , Cmax, Sp, numPath &#x3D; 0, G[MAXV][MAXV], weight[MAXV];</span><br><span class="line">int d[MAXV], minNeed &#x3D; INF, minRemain &#x3D; INF;</span><br><span class="line">bool vis[MAXV] &#x3D; &#123;false&#125;;&#x2F;&#x2F;vis[i] &#x3D;&#x3D; true 表示顶点i已访问，初始均为false</span><br><span class="line">vector&lt;int&gt; pre[MAXV];&#x2F;&#x2F;前驱</span><br><span class="line">vector&lt;int&gt; tempPath, path;&#x2F;&#x2F;临时路径及最优路径</span><br><span class="line"></span><br><span class="line">void Dijkstra(int s)&#123;&#x2F;&#x2F;s为起点</span><br><span class="line">    fill(d, d + MAXV, INF);</span><br><span class="line">    d[s] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;&#x2F;&#x2F;循环n次</span><br><span class="line">        int u &#x3D; -1, MIN &#x3D; INF;&#x2F;&#x2F;u使d[u]最小，MIN存放该最小的d[u]</span><br><span class="line">        for (int j &#x3D; 0; j &lt;&#x3D; n; j++) &#123;&#x2F;&#x2F;找到未访问的顶点中d[]最小的</span><br><span class="line">            if (vis[j] &#x3D;&#x3D; false &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u &#x3D; j;</span><br><span class="line">                MIN &#x3D; d[j];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;找不到小于INF的d[u]，说明剩下的顶点和起点s不连通</span><br><span class="line">        if (u &#x3D;&#x3D; -1) return;</span><br><span class="line">        vis[u] &#x3D; true;&#x2F;&#x2F;标记u已访问</span><br><span class="line">        for (int v &#x3D; 0; v &lt;&#x3D; n; v++) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果v未访问&amp;&amp; u能到达v</span><br><span class="line">            if (vis[v] &#x3D;&#x3D; false &amp;&amp; G[u][v] !&#x3D; INF) &#123;</span><br><span class="line">                if (d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] &#x3D; d[u] + G[u][v];&#x2F;&#x2F;优化d[v]</span><br><span class="line">                    pre[v].clear();</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;else if (d[u] + G[u][v] &#x3D;&#x3D; d[v])&#123;</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int v)&#123;</span><br><span class="line">    if(v &#x3D;&#x3D; 0)&#123;&#x2F;&#x2F;递归边界,叶子结点</span><br><span class="line">        tempPath.push_back(v);</span><br><span class="line">        &#x2F;&#x2F;路径tempPath上需要携带数目、需要带回的数目</span><br><span class="line">        int need &#x3D; 0, remain &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; tempPath.size() - 1; i &gt;&#x3D; 0 ; i--) &#123;</span><br><span class="line">            int id &#x3D; tempPath[i];&#x2F;&#x2F;当前结点编号id</span><br><span class="line">            if (weight[id] &gt; 0) &#123;&#x2F;&#x2F;点权大于0，说明需要带走一部分自行车</span><br><span class="line">                remain +&#x3D; weight[id];</span><br><span class="line">            &#125;else&#123;&#x2F;&#x2F;点权不超过0，需要补给</span><br><span class="line">                if (remain &gt; abs(weight[id])) &#123;&#x2F;&#x2F;当前持有量足够补给</span><br><span class="line">                    remain -&#x3D; abs(weight[id]);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    need +&#x3D; abs(weight[id]) - remain;&#x2F;&#x2F;不够的部分从PBMC携带</span><br><span class="line">                    remain &#x3D; 0;&#x2F;&#x2F;当前持有的自行车都用来补给</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (need &lt; minNeed)&#123;&#x2F;&#x2F;需要从PBMC携带的自行车数目更少</span><br><span class="line">            minNeed &#x3D; need;&#x2F;&#x2F;优化minNeed</span><br><span class="line">            minRemain &#x3D; remain;&#x2F;&#x2F;覆盖minRemain</span><br><span class="line">            path &#x3D; tempPath;&#x2F;&#x2F;覆盖最优路径path</span><br><span class="line">        &#125;else if(need &#x3D;&#x3D; minNeed &amp;&amp; remain &lt; minRemain)&#123;</span><br><span class="line">            &#x2F;&#x2F;携带数目相同，带回数目变少</span><br><span class="line">            minRemain &#x3D; remain;&#x2F;&#x2F;优化minRemain</span><br><span class="line">            path &#x3D; tempPath;&#x2F;&#x2F;覆盖最优路径path</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.push_back(v);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; pre[v].size(); i++) &#123;</span><br><span class="line">        DFS(pre[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;, &amp;Cmax, &amp;n, &amp;Sp, &amp;m);</span><br><span class="line">    int u, v;</span><br><span class="line">    fill(G[0], G[0] + MAXV * MAXV, INF);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;weight[i]);</span><br><span class="line">        weight[i] -&#x3D; Cmax &#x2F; 2;&#x2F;&#x2F;点权减去答案的一半</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;G[u][v]);</span><br><span class="line">        G[v][u] &#x3D; G[u][v];</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(0);&#x2F;&#x2F;Dijkstra算法入口</span><br><span class="line">    DFS(Sp);</span><br><span class="line">    printf(&quot;%d &quot;, minNeed);</span><br><span class="line">    for (int i &#x3D; path.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, path[i]);</span><br><span class="line">        if (i &gt; 0) &#123;</span><br><span class="line">            printf(&quot;-&gt;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot; %d\n&quot;, minRemain);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/25/230/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/25/230/" class="post-title-link" itemprop="url">PAT A1003</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-02-25 15:57:03 / 修改时间：16:08:54" itemprop="dateCreated datePublished" datetime="2017-02-25T15:57:03+00:00">2017-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible.</p>
<p>Input</p>
<p>Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (&lt;= 500) - the number of cities (and the cities are numbered from 0 to N-1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2.</p>
<p>Output</p>
<p>For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather.<br>All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line.</p>
<p>Sample Input<br>5 6 0 2<br>1 2 1 5 3<br>0 1 1<br>0 2 2<br>0 3 1<br>1 2 1<br>2 4 1<br>3 4 1<br>Sample Output<br>2 4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &quot;set&quot;</span><br><span class="line">#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXV &#x3D; 510;&#x2F;&#x2F;最大顶点数</span><br><span class="line">const int INF &#x3D; 1000000000;&#x2F;&#x2F;无穷大</span><br><span class="line">&#x2F;&#x2F;n为顶点数，m为边数，st和ed分别起点和终点</span><br><span class="line">&#x2F;&#x2F;G为邻接矩阵，weight为点权</span><br><span class="line">&#x2F;&#x2F;d[]记录最短距离，w[]记录最大点权之和，num[]记录最短路径条数</span><br><span class="line">int n, m, st, ed, G[MAXV][MAXV], weight[MAXV];</span><br><span class="line">int d[MAXV], w[MAXV], num[MAXV];</span><br><span class="line">bool vis[MAXV] &#x3D; &#123;false&#125;;&#x2F;&#x2F;vis[i]&#x3D;&#x3D;true表示顶点i已访问，初始均为false</span><br><span class="line"></span><br><span class="line">void Dijstra(int s)&#123;&#x2F;&#x2F;s为起点</span><br><span class="line">    fill(d, d + MAXV, INF);</span><br><span class="line">    memset(num, 0, sizeof(num));</span><br><span class="line">    memset(w, 0, sizeof(w));</span><br><span class="line">    d[s] &#x3D; 0;&#x2F;&#x2F;s到s的距离是0</span><br><span class="line">    w[s] &#x3D; weight[s];</span><br><span class="line">    num[s] &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;&#x2F;&#x2F;循环n次</span><br><span class="line">        int u &#x3D; -1, MIN &#x3D; INF;&#x2F;&#x2F;u使d[u]最小，MIN存放该最小的d[u]</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; j++) &#123;&#x2F;&#x2F;找到未访问的顶点中d[]最小的</span><br><span class="line">            if (vis[j] &#x3D;&#x3D; false &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u &#x3D; j;</span><br><span class="line">                MIN &#x3D; d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;找不到小于INF的d[u]，说明剩下的顶点和起点s不连通</span><br><span class="line">        if (u &#x3D;&#x3D; -1) return;</span><br><span class="line">        vis[u] &#x3D; true;&#x2F;&#x2F;标记u为已访问</span><br><span class="line">        for (int v &#x3D; 0; v &lt; n; v++) &#123;</span><br><span class="line">            &#x2F;&#x2F;如果v未访问&amp;&amp;u能到达v&amp;&amp;以u为中介点可以使d[v]更优</span><br><span class="line">            if (vis[v] &#x3D;&#x3D; false &amp;&amp; G[u][v] !&#x3D; INF)&#123;</span><br><span class="line">                if (d[u] + G[u][v] &lt; d[v]) &#123;&#x2F;&#x2F;以u为中介点时能令d[v]变小</span><br><span class="line">                    d[v] &#x3D; d[u] + G[u][v];&#x2F;&#x2F;覆盖d[v]</span><br><span class="line">                    w[v] &#x3D; w[u] + weight[v];&#x2F;&#x2F;覆盖w[v]</span><br><span class="line">                    num[v] &#x3D; num[u];&#x2F;&#x2F;覆盖num[v]</span><br><span class="line">                &#125;else if (d[u] + G[u][v] &#x3D;&#x3D; d[v])&#123;&#x2F;&#x2F;找到一条相同长度的路径</span><br><span class="line">                    if (w[u] + weight[v] &gt; w[v]) &#123;&#x2F;&#x2F;以u为中介点时点权之和更大</span><br><span class="line">                        w[v] &#x3D; w[u] + weight[v];&#x2F;&#x2F;w[v]继承自w[u]</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F;注意最短路径条数与点权无关，必须写在外面</span><br><span class="line">                    num[v] +&#x3D; num[u];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;st, &amp;ed);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;weight[i]);&#x2F;&#x2F;读入点权</span><br><span class="line">    &#125;</span><br><span class="line">    int u, v;</span><br><span class="line">    fill(G[0], G[0] + MAXV * MAXV, INF);&#x2F;&#x2F;初始化图G</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i ++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;G[u][v]);&#x2F;&#x2F;读入边权</span><br><span class="line">        G[v][u] &#x3D; G[u][v];</span><br><span class="line">    &#125;</span><br><span class="line">    Dijstra(st);&#x2F;&#x2F;dijstra算法入口</span><br><span class="line">    printf(&quot;%d %d\n&quot;, num[ed], w[ed]);&#x2F;&#x2F;最短距离条数，最短路径中的最大点权</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此题在最短路径的基础上增加了点权和最短路径条数<br>一般来讲会有三种出题方式：<br>1、增加边权 2、增加点权 3、求最短路径条数<br>这三种都是在d[u] + G[u][v] == d[v]的条件下判断<br>其中前两种类似于<br>c[v] = c[u] + cost[u][v];<br>w[v] = w[u] + weight[v];<br>后一种增加num[],初始化时令num[s] = 1;其余均为0；<br>当在条件出现的时候，num[v] += num[u];</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/24/227/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/24/227/" class="post-title-link" itemprop="url">PAT A1021</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-02-24 19:34:00" itemprop="dateCreated datePublished" datetime="2017-02-24T19:34:00+00:00">2017-02-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2017-02-25 11:15:21" itemprop="dateModified" datetime="2017-02-25T11:15:21+00:00">2017-02-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=10000) which is the number of nodes, and hence the nodes are numbered from 1 to N. Then N-1 lines follow, each describes an edge by given the two adjacent nodes’ numbers.</p>
<p>Output Specification:</p>
<p>For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print “Error: K components” where K is the number of connected components in the graph.</p>
<p>Sample Input 1:<br>5<br>1 2<br>1 3<br>1 4<br>2 5<br>Sample Output 1:<br>3<br>4<br>5<br>Sample Input 2:<br>5<br>1 3<br>1 4<br>2 5<br>3 4<br>Sample Output 2:<br>Error: 2 components<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &quot;set&quot;</span><br><span class="line">#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;typedef long long LL;</span><br><span class="line">const int N &#x3D; 10010;</span><br><span class="line">vector&lt;int&gt; G[N];&#x2F;&#x2F;邻接表</span><br><span class="line">vector&lt;int&gt; deepestRoot, ans;</span><br><span class="line">bool vis[N] &#x3D; &#123;false&#125;;&#x2F;&#x2F;标记顶点i是否已经被访问</span><br><span class="line">int n, maxDepth &#x3D; -1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;dfs遍历v所在的连通块</span><br><span class="line">void dfs(int v,int depth)&#123;</span><br><span class="line">    if (depth &gt; maxDepth) &#123;</span><br><span class="line">        maxDepth &#x3D; depth;</span><br><span class="line">        deepestRoot.clear();</span><br><span class="line">        deepestRoot.push_back(v);</span><br><span class="line">        </span><br><span class="line">    &#125;else if(depth &#x3D;&#x3D; maxDepth)&#123;</span><br><span class="line">        deepestRoot.push_back(v);</span><br><span class="line">    &#125;</span><br><span class="line">    vis[v] &#x3D; true;&#x2F;&#x2F;v点被访问</span><br><span class="line">    for (int i &#x3D; 0; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">        if (vis[G[v][i]] &#x3D;&#x3D; false) &#123;&#x2F;&#x2F;如果顶点G[v][i]未被访问</span><br><span class="line">            dfs(G[v][i], depth + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int block &#x3D; 0;</span><br><span class="line">void dfstrave()&#123;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        if (vis[i] &#x3D;&#x3D; false) &#123;</span><br><span class="line">            dfs(i, 0);</span><br><span class="line">            block++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n - 1; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    dfstrave();</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    set&lt;int&gt; sRoot;</span><br><span class="line">    if (block &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;是树</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; deepestRoot.size(); i++) &#123;</span><br><span class="line">            sRoot.insert(deepestRoot[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(deepestRoot[0], 0);</span><br><span class="line">        for (int i &#x3D; 0 ; i &lt; deepestRoot.size(); i++) &#123;</span><br><span class="line">                sRoot.insert(deepestRoot[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        set&lt;int&gt;::iterator it &#x3D; sRoot.begin();</span><br><span class="line">        for (; it !&#x3D; sRoot.end() ; it++) &#123;</span><br><span class="line">            printf(&quot;%d\n&quot;, *it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;Error: %d components\n&quot;, block);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>并查集版本（算法笔记）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">    #include &quot;stdio.h&quot;</span><br><span class="line">    #include &quot;math.h&quot;</span><br><span class="line">    #include &quot;string.h&quot;</span><br><span class="line">    #include &quot;iostream&quot;</span><br><span class="line">    &#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">    #include &quot;vector&quot;</span><br><span class="line">    #include &quot;set&quot;</span><br><span class="line">    #include &quot;map&quot;</span><br><span class="line">    &#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">    #include &quot;queue&quot;</span><br><span class="line">    #include &quot;algorithm&quot;</span><br><span class="line">    using namespace std;</span><br><span class="line">    </span><br><span class="line">    const int N &#x3D; 110;</span><br><span class="line">    vector&lt;int&gt; G[N];&#x2F;&#x2F;邻接表</span><br><span class="line">    </span><br><span class="line">    bool isRoot[N];&#x2F;&#x2F;记录每个结点是否作为某个集合的根结点</span><br><span class="line">    int father[N];&#x2F;&#x2F;并查集</span><br><span class="line">    int findFather(int x)&#123;</span><br><span class="line">        int a &#x3D; x;</span><br><span class="line">        while (x !&#x3D; father[x]) &#123;</span><br><span class="line">            x &#x3D; father[x];</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;路径压缩</span><br><span class="line">        while (a !&#x3D; father[a]) &#123;</span><br><span class="line">            int z &#x3D; a;</span><br><span class="line">            a &#x3D; father[a];</span><br><span class="line">            father[z] &#x3D; x;</span><br><span class="line">        &#125;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">    void Union(int a, int b) &#123;&#x2F;&#x2F;合并a和b所在的集合</span><br><span class="line">        int faA &#x3D; findFather(a);</span><br><span class="line">        int faB &#x3D; findFather(b);</span><br><span class="line">        if (faA !&#x3D; faB) &#123;</span><br><span class="line">            father[faA] &#x3D; faB;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    void init(int n)&#123;&#x2F;&#x2F;并查集初始化</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            father[i] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int calBlock(int n)&#123;&#x2F;&#x2F;计算连通块个数</span><br><span class="line">        int Block &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            isRoot[findFather(i)] &#x3D; true;&#x2F;&#x2F;i的根节点是findFather(i)</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">            Block +&#x3D; isRoot[i];&#x2F;&#x2F;累加根结点个数</span><br><span class="line">        &#125;</span><br><span class="line">        return Block;</span><br><span class="line">    &#125;</span><br><span class="line">    int maxH &#x3D; 0;&#x2F;&#x2F;最大高度</span><br><span class="line">    vector&lt;int&gt; temp, ans;&#x2F;&#x2F;temp临时存放dfs的最远结点结果，ans保存答案</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;dfs函数,u为当前访问结点编号，height为当前树高，pre为u的父节点</span><br><span class="line">    void dfs(int u, int height, int pre)&#123;</span><br><span class="line">        if (height &gt; maxH) &#123;&#x2F;&#x2F;获得了更大的树高</span><br><span class="line">            temp.clear();&#x2F;&#x2F;清空temp</span><br><span class="line">            temp.push_back(u);&#x2F;&#x2F;将当前结点u加入temp中</span><br><span class="line">            maxH &#x3D; height;&#x2F;&#x2F;更新最大树高</span><br><span class="line">        &#125;else if(height &#x3D;&#x3D; maxH)&#123;</span><br><span class="line">            temp.push_back(u);&#x2F;&#x2F;加入当前结点到temp中</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; G[u].size(); i++) &#123;&#x2F;&#x2F;遍历u的所有子节点</span><br><span class="line">            &#x2F;&#x2F;由于邻接表中存放无向图，因此需要跳过回去的边</span><br><span class="line">            if (G[u][i] &#x3D;&#x3D; pre) continue;</span><br><span class="line">            dfs(G[u][i], height + 1, u);&#x2F;&#x2F;访问子节点</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int main()&#123;</span><br><span class="line">        int a, b, n;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">        init(n);</span><br><span class="line">        for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">            scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">            G[a].push_back(b);&#x2F;&#x2F;边a-&gt;b</span><br><span class="line">            G[b].push_back(a);&#x2F;&#x2F;边b-&gt;a</span><br><span class="line">            Union(a, b);&#x2F;&#x2F;合并a和b所在的集合</span><br><span class="line">        &#125;</span><br><span class="line">        int Block &#x3D; calBlock(n);&#x2F;&#x2F;计算集合数目</span><br><span class="line">        if (Block !&#x3D; 1) &#123;&#x2F;&#x2F;不止一个连通块</span><br><span class="line">            printf(&quot;Error: %d components\n&quot;, Block);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            dfs(1, 1, -1);&#x2F;&#x2F;从1号结点开始dfs，初始高度为1</span><br><span class="line">            ans &#x3D; temp;&#x2F;&#x2F;temp为集合A，赋值给ans</span><br><span class="line">            dfs(ans[0], 1, -1);&#x2F;&#x2F;从任意一个根节点开始遍历</span><br><span class="line">            for (int i &#x3D; 0; i &lt; temp.size(); i++) &#123;</span><br><span class="line">                ans.push_back(temp[i]);&#x2F;&#x2F;此时temp为集合b，将其加到ans中</span><br><span class="line">            &#125;</span><br><span class="line">            sort(ans.begin(), ans.end());&#x2F;&#x2F;按编号从小到大排序</span><br><span class="line">            printf(&quot;%d\n&quot;, ans[0]);</span><br><span class="line">            for (int i &#x3D; 1; i &lt; ans.size(); i++) &#123;</span><br><span class="line">                if (ans[i] !&#x3D; ans[i - 1]) &#123;&#x2F;&#x2F;重复编号不输出</span><br><span class="line">                    printf(&quot;%d\n&quot;, ans[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#x2F;&#x2F;        dfs(1, 1, -1);&#x2F;&#x2F;从1号结点开始dfs，初始高度为1</span><br><span class="line">&#x2F;&#x2F;        set&lt;int&gt; setofRoot;</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; temp.size(); i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            setofRoot.insert(temp[i]);</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        dfs(temp[0], 1, -1);</span><br><span class="line">&#x2F;&#x2F;        for (int i &#x3D; 0; i &lt; temp.size(); i++) &#123;</span><br><span class="line">&#x2F;&#x2F;            setofRoot.insert(temp[i]);</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line">&#x2F;&#x2F;        for (set&lt;int&gt;::iterator it &#x3D; setofRoot.begin(); it !&#x3D; setofRoot.end(); it++) &#123;</span><br><span class="line">&#x2F;&#x2F;            printf(&quot;%d\n&quot;, *it);</span><br><span class="line">&#x2F;&#x2F;        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>注释中是用集合实现deepest root的储存</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/24/226/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/24/226/" class="post-title-link" itemprop="url">PAT A1013</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-02-24 19:16:12 / 修改时间：19:32:29" itemprop="dateCreated datePublished" datetime="2017-02-24T19:16:12+00:00">2017-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>It is vitally important to have all the cities connected by highways in a war. If a city is occupied by the enemy, all the highways from/toward that city are closed. We must know immediately if we need to repair any other highways to keep the rest of the cities connected. Given the map of cities which have all the remaining highways marked, you are supposed to tell the number of highways need to be repaired, quickly.</p>
<p>For example, if we have 3 cities and 2 highways connecting city1-city2 and city1-city3. Then if city1 is occupied by the enemy, we must have 1 highway repaired, that is the highway city2-city3.</p>
<p>Input</p>
<p>Each input file contains one test case. Each case starts with a line containing 3 numbers N (&lt;1000), M and K, which are the total number of cities, the number of remaining highways, and the number of cities to be checked, respectively. Then M lines follow, each describes a highway by 2 integers, which are the numbers of the cities the highway connects. The cities are numbered from 1 to N. Finally there is a line containing K numbers, which represent the cities we concern.</p>
<p>Output</p>
<p>For each of the K cities, output in a line the number of highways need to be repaired if that city is lost.</p>
<p>Sample Input<br>3 2 3<br>1 2<br>1 3<br>1 2 3<br>Sample Output<br>1<br>0<br>0<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;set&quot;</span><br><span class="line">#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;typedef long long LL;</span><br><span class="line">const int N &#x3D; 1111;</span><br><span class="line">vector&lt;int&gt; G[N];&#x2F;&#x2F;邻接表</span><br><span class="line">bool vis[N];&#x2F;&#x2F;标记顶点i是否已经被访问</span><br><span class="line">int currentPoint;</span><br><span class="line">&#x2F;&#x2F;dfs遍历v所在的连通块</span><br><span class="line">void dfs(int v)&#123;</span><br><span class="line">    if (v &#x3D;&#x3D; currentPoint)  return;</span><br><span class="line">    vis[v] &#x3D; true;&#x2F;&#x2F;v点被访问</span><br><span class="line">    for (int i &#x3D; 0; i &lt; G[v].size(); i++) &#123;</span><br><span class="line">        if (vis[G[v][i]] &#x3D;&#x3D; false) &#123;&#x2F;&#x2F;如果顶点G[v][i]未被访问</span><br><span class="line">            dfs(G[v][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int n, m, k;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        int a, b;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);&#x2F;&#x2F;输入边的两个结点</span><br><span class="line">        G[a].push_back(b);</span><br><span class="line">        G[b].push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int query &#x3D; 0; query &lt; k; query++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;currentPoint);&#x2F;&#x2F;欲删除的顶点编号</span><br><span class="line">        memset(vis, false, sizeof(vis));</span><br><span class="line">        int block &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;&#x2F;&#x2F;枚举每个顶点</span><br><span class="line">            if (i !&#x3D; currentPoint &amp;&amp; vis[i] &#x3D;&#x3D; false) &#123;&#x2F;&#x2F;如果未被删除且未被访问</span><br><span class="line">                dfs(i);</span><br><span class="line">                block++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d\n&quot;, block - 1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/24/225/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/24/225/" class="post-title-link" itemprop="url">PAT A1076</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-02-24 18:43:23 / 修改时间：19:05:09" itemprop="dateCreated datePublished" datetime="2017-02-24T18:43:23+00:00">2017-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L levels of indirect followers are counted.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers: N (&lt;=1000), the number of users; and L (&lt;=6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N. Then N lines follow, each in the format:</p>
<p>M[i] user_list[i]</p>
<p>where M[i] (&lt;=100) is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that are followed by user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.</p>
<p>Then finally a positive K is given, followed by K UserID’s for query.</p>
<p>Output Specification:</p>
<p>For each UserID, you are supposed to print in one line the maximum potential amount of forwards this user can triger, assuming that everyone who can view the initial post will forward it once, and that only L levels of indirect followers are counted.</p>
<p>Sample Input:<br>7 3<br>3 2 3 4<br>0<br>2 5 6<br>2 3 1<br>2 3 4<br>1 4<br>1 5<br>2 2 6<br>Sample Output:<br>4<br>5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;set&quot;</span><br><span class="line">#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;typedef long long LL;</span><br><span class="line">const int MAXV &#x3D; 1010;</span><br><span class="line">struct Node&#123;</span><br><span class="line">    int id;</span><br><span class="line">    int layer;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Node&gt; Adj[MAXV];&#x2F;&#x2F;邻接表</span><br><span class="line">bool inq[MAXV] &#x3D; &#123;false&#125;;&#x2F;&#x2F;顶点是否已被加入过队列</span><br><span class="line">int BFS(int s, int L)&#123;&#x2F;&#x2F;start为起始结点，L为层数上限</span><br><span class="line">    int numForward &#x3D; 0;&#x2F;&#x2F;转发数</span><br><span class="line">    queue&lt;Node&gt; q;</span><br><span class="line">    Node start;</span><br><span class="line">    start.id &#x3D; s;</span><br><span class="line">    start.layer &#x3D; 0;</span><br><span class="line">    q.push(start);</span><br><span class="line">    inq[s] &#x3D; true;</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        Node topNode &#x3D; q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        int u &#x3D; topNode.id;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; Adj[u].size(); i++) &#123;</span><br><span class="line">            Node next &#x3D; Adj[u][i];&#x2F;&#x2F;从u出发能到达的结点next</span><br><span class="line">            next.layer &#x3D; topNode.layer + 1;&#x2F;&#x2F;next的层号等于当前结点层号加1</span><br><span class="line">            &#x2F;&#x2F;如果next的编号未被加入过队列，且next的层次不超过上限L</span><br><span class="line">            if (inq[next.id] &#x3D;&#x3D; false &amp;&amp; next.layer &lt;&#x3D; L) &#123;</span><br><span class="line">                q.push(next);</span><br><span class="line">                inq[next.id] &#x3D; true;</span><br><span class="line">                numForward++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return numForward;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Node user;</span><br><span class="line">    int n, L, numFollow, idFollow;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;L);&#x2F;&#x2F;结点个数，层数上限</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        user.id &#x3D; i;&#x2F;&#x2F;用户编号为i</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;numFollow);&#x2F;&#x2F;i用户关注的人数</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; numFollow; j++) &#123;</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;idFollow);</span><br><span class="line">            Adj[idFollow].push_back(user);&#x2F;&#x2F;idFollow-&gt;i 被i用户关注</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int numQuery, s;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;numQuery);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; numQuery; i++) &#123;</span><br><span class="line">        memset(inq, false, sizeof(inq));&#x2F;&#x2F;inq数组初始化</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;s);</span><br><span class="line">        int numForward &#x3D; BFS(s, L);&#x2F;&#x2F;BFS,返回转发数</span><br><span class="line">        printf(&quot;%d\n&quot;, numForward);&#x2F;&#x2F;输出转发数</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/24/224/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/24/224/" class="post-title-link" itemprop="url">PAT A1034</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-02-24 18:34:13 / 修改时间：18:34:24" itemprop="dateCreated datePublished" datetime="2017-02-24T18:34:13+00:00">2017-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between A and B, we say that A and B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold K. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains two positive numbers N and K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N lines follow, each in the following format:</p>
<p>Name1 Name2 Time</p>
<p>where Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A-Z. A time length is a positive integer which is no more than 1000 minutes.</p>
<p>Output Specification:</p>
<p>For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.</p>
<p>Sample Input 1:<br>8 59<br>AAA BBB 10<br>BBB AAA 20<br>AAA CCC 40<br>DDD EEE 5<br>EEE DDD 70<br>FFF GGG 30<br>GGG HHH 20<br>HHH FFF 10<br>Sample Output 1:<br>2<br>AAA 3<br>GGG 3<br>Sample Input 2:<br>8 70<br>AAA BBB 10<br>BBB AAA 20<br>AAA CCC 40<br>DDD EEE 5<br>EEE DDD 70<br>FFF GGG 30<br>GGG HHH 20<br>HHH FFF 10<br>Sample Output 2:<br>0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;set&quot;</span><br><span class="line">#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;typedef long long LL;</span><br><span class="line">const int maxn &#x3D; 2010;&#x2F;&#x2F;总人数</span><br><span class="line">const int INF &#x3D; 1000000000;&#x2F;&#x2F;无穷大</span><br><span class="line"></span><br><span class="line">map&lt;int, string&gt; intToString;&#x2F;&#x2F;编号-&gt;姓名</span><br><span class="line">map&lt;string, int&gt; stringToInt;&#x2F;&#x2F;姓名-&gt;编号</span><br><span class="line">map&lt;string, int&gt; Gang;&#x2F;&#x2F;head-&gt;人数</span><br><span class="line">int G[maxn][maxn] &#x3D; &#123;0&#125;, weight[maxn] &#x3D; &#123;0&#125;;&#x2F;&#x2F;邻接矩阵G，点权weight</span><br><span class="line">int n, k, numPerson &#x3D; 0;&#x2F;&#x2F;边数n, 下限k, 总人数numPerson</span><br><span class="line">bool vis[maxn] &#x3D; &#123;false&#125;;&#x2F;&#x2F;标记是否被访问</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;DFS函数访问单个连通块，nowVisit为当前访问的编号</span><br><span class="line">&#x2F;&#x2F;head为头目，numMember为成员编号，totoalValue为连通块的总边权</span><br><span class="line">void DFS(int nowVisit, int&amp; head, int&amp; numMember, int&amp; totalValue)&#123;</span><br><span class="line">    numMember++;&#x2F;&#x2F;成员人数加1</span><br><span class="line">    vis[nowVisit] &#x3D; true;&#x2F;&#x2F;标记nowVisit已访问</span><br><span class="line">    if (weight[nowVisit] &gt; weight[head]) &#123;</span><br><span class="line">        head &#x3D; nowVisit;&#x2F;&#x2F;换老大了</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; numPerson; i++) &#123;&#x2F;&#x2F;枚举所有人</span><br><span class="line">        if (G[nowVisit][i] &gt; 0) &#123;&#x2F;&#x2F;如果从nowVisit能达到i</span><br><span class="line">            totalValue +&#x3D; G[nowVisit][i];&#x2F;&#x2F;连通块的总边权增加该边权</span><br><span class="line">            G[nowVisit][i] &#x3D; G[i][nowVisit] &#x3D; 0;&#x2F;&#x2F;删除这条边，防止回头</span><br><span class="line">            if (vis[i] &#x3D;&#x3D; false) &#123;</span><br><span class="line">                DFS(i, head, numMember, totalValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;DFSTrave函数遍历整个图，获取每个连通块的信息</span><br><span class="line">void DFSTrave()&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; numPerson; i++) &#123;&#x2F;&#x2F;枚举所有人</span><br><span class="line">        if (vis[i] &#x3D;&#x3D; false) &#123;</span><br><span class="line">            int head &#x3D; i, numMember &#x3D; 0, totalValue &#x3D; 0;&#x2F;&#x2F;头目、成员数目，总边权</span><br><span class="line">            DFS(i, head, numMember, totalValue);</span><br><span class="line">            if (numMember &gt; 2 &amp;&amp; totalValue &gt; k) &#123;</span><br><span class="line">                &#x2F;&#x2F;head人数为numMember</span><br><span class="line">                Gang[intToString[head]] &#x3D; numMember;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;change函数返回姓名str对应的编号</span><br><span class="line">int change(string str)&#123;</span><br><span class="line">    if (stringToInt.find(str) !&#x3D; stringToInt.end()) &#123;&#x2F;&#x2F;如果str已经出现过</span><br><span class="line">        return stringToInt[str];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        stringToInt[str] &#x3D; numPerson;&#x2F;&#x2F;str的编号为strPerson</span><br><span class="line">        intToString[numPerson] &#x3D; str;&#x2F;&#x2F;建立对应关系</span><br><span class="line">        return numPerson++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int w;</span><br><span class="line">    string str1, str2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; str1 &gt;&gt; str2 &gt;&gt; w;&#x2F;&#x2F;输入两个边的端点和点权</span><br><span class="line">        int id1 &#x3D; change(str1);</span><br><span class="line">        int id2 &#x3D; change(str2);</span><br><span class="line">        weight[id1] +&#x3D; w;</span><br><span class="line">        weight[id2] +&#x3D; w;</span><br><span class="line">        G[id1][id2] +&#x3D; w;</span><br><span class="line">        G[id2][id1] +&#x3D; w;</span><br><span class="line">    &#125;</span><br><span class="line">    DFSTrave();&#x2F;&#x2F;遍历整个图所有连通块，获取gang的信息</span><br><span class="line">    cout &lt;&lt; Gang.size() &lt;&lt; endl;&#x2F;&#x2F;gang的个数</span><br><span class="line">    map&lt;string, int&gt;::iterator it;</span><br><span class="line">    for (it &#x3D; Gang.begin(); it !&#x3D; Gang.end(); it++) &#123;&#x2F;&#x2F;遍历所有gang</span><br><span class="line">        cout &lt;&lt; it-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/24/220/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/24/220/" class="post-title-link" itemprop="url">PAT A1098 . Insertion or Heap Sort (25)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-02-24 12:40:00" itemprop="dateCreated datePublished" datetime="2017-02-24T12:40:00+00:00">2017-02-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2017-03-03 15:55:46" itemprop="dateModified" datetime="2017-03-03T15:55:46+00:00">2017-03-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A “social cluster” is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. For each test case, the first line contains a positive integer N (&lt;=1000), the total number of people in a social network. Hence the people are numbered from 1 to N. Then N lines follow, each gives the hobby list of a person in the format:</p>
<p>Ki: hi[1] hi[2] … hi[Ki]</p>
<p>where Ki (&gt;0) is the number of hobbies, and hi[j] is the index of the j-th hobby, which is an integer in [1, 1000].</p>
<p><strong>Output Specification:</strong></p>
<p>For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<p><strong>Sample Input:</strong><br>8<br>3: 2 7 10<br>1: 4<br>2: 5 3<br>1: 4<br>1: 3<br>1: 4<br>4: 6 8 1 5<br>1: 4<br><strong>Sample Output:</strong><br>3<br>4 3 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;set&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;typedef long long LL;</span><br><span class="line">const int maxn&#x3D; 1010;</span><br><span class="line">int father[maxn];&#x2F;&#x2F;存放父亲结点</span><br><span class="line">int isRoot[maxn] &#x3D; &#123;0&#125;;&#x2F;&#x2F;记录每个结点是否作为某个集合的根结点</span><br><span class="line">int course[maxn] &#x3D; &#123;0&#125;;&#x2F;&#x2F;记录喜欢活动h的任意一个人的编号</span><br><span class="line">int findFather(int x)&#123;&#x2F;&#x2F;查找x所在集合的根节点</span><br><span class="line">    int a &#x3D; x;</span><br><span class="line">    while (x !&#x3D; father[x]) &#123;</span><br><span class="line">        x &#x3D; father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;路径压缩</span><br><span class="line">    while (a !&#x3D; father[a]) &#123;</span><br><span class="line">        int z &#x3D; a;</span><br><span class="line">        a &#x3D; father[a];</span><br><span class="line">        father[z] &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">void Union(int a, int b)&#123;&#x2F;&#x2F;合并a和b所在的集合</span><br><span class="line">    int faA &#x3D; findFather(a);</span><br><span class="line">    int faB &#x3D; findFather(b);</span><br><span class="line">    if (faA !&#x3D; faB) &#123;</span><br><span class="line">        father[faA] &#x3D; faB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init(int n)&#123;&#x2F;&#x2F;初始化father[i]为i，且isRoot[i]为false</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        father[i] &#x3D; i;</span><br><span class="line">        isRoot[i] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp(int a, int b)&#123;</span><br><span class="line">    return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, k, h;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    init(n);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d:&quot;, &amp;k);</span><br><span class="line">        for (int j &#x3D; 0; j &lt; k; j++) &#123;&#x2F;&#x2F;对每个活动</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;h);</span><br><span class="line">            if (course[h] &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;h活动第一次有人喜欢</span><br><span class="line">                course[h] &#x3D; i;&#x2F;&#x2F;记录那个人的名字</span><br><span class="line">            &#125;</span><br><span class="line">            Union(i, findFather(course[h]));&#x2F;&#x2F;合并</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        isRoot[findFather(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        if (isRoot[i]) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    sort(isRoot + 1, isRoot + n + 1, cmp);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; ans; i++) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, isRoot[i]);</span><br><span class="line">        if (i &lt; ans) &#123;</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/24/219/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/24/219/" class="post-title-link" itemprop="url">PAT A1107 . Social Clusters</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-02-24 10:34:00" itemprop="dateCreated datePublished" datetime="2017-02-24T10:34:00+00:00">2017-02-24</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2017-03-03 15:54:32" itemprop="dateModified" datetime="2017-03-03T15:54:32+00:00">2017-03-03</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>When register on a social network, you are always asked to specify your hobbies in order to find some potential friends with the same hobbies. A “social cluster” is a set of people who have some of their hobbies in common. You are supposed to find all the clusters.</p>
<p><strong>Input Specification:</strong></p>
<p>Each input file contains one test case. For each test case, the first line contains a positive integer N (&lt;=1000), the total number of people in a social network. Hence the people are numbered from 1 to N. Then N lines follow, each gives the hobby list of a person in the format:</p>
<p>Ki: hi[1] hi[2] … hi[Ki]</p>
<p>where Ki (&gt;0) is the number of hobbies, and hi[j] is the index of the j-th hobby, which is an integer in [1, 1000].</p>
<p><strong>Output Specification:</strong></p>
<p>For each case, print in one line the total number of clusters in the network. Then in the second line, print the numbers of people in the clusters in non-increasing order. The numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>
<p><strong>Sample Input:</strong><br>8<br>3: 2 7 10<br>1: 4<br>2: 5 3<br>1: 4<br>1: 3<br>1: 4<br>4: 6 8 1 5<br>1: 4<br><strong>Sample Output:</strong><br>3<br>4 3 1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;set&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;typedef long long LL;</span><br><span class="line">const int maxn&#x3D; 1010;</span><br><span class="line">int father[maxn];&#x2F;&#x2F;存放父亲结点</span><br><span class="line">int isRoot[maxn] &#x3D; &#123;0&#125;;&#x2F;&#x2F;记录每个结点是否作为某个集合的根结点</span><br><span class="line">int course[maxn] &#x3D; &#123;0&#125;;&#x2F;&#x2F;记录喜欢活动h的任意一个人的编号</span><br><span class="line">int findFather(int x)&#123;&#x2F;&#x2F;查找x所在集合的根节点</span><br><span class="line">    int a &#x3D; x;</span><br><span class="line">    while (x !&#x3D; father[x]) &#123;</span><br><span class="line">        x &#x3D; father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;路径压缩</span><br><span class="line">    while (a !&#x3D; father[a]) &#123;</span><br><span class="line">        int z &#x3D; a;</span><br><span class="line">        a &#x3D; father[a];</span><br><span class="line">        father[z] &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">void Union(int a, int b)&#123;&#x2F;&#x2F;合并a和b所在的集合</span><br><span class="line">    int faA &#x3D; findFather(a);</span><br><span class="line">    int faB &#x3D; findFather(b);</span><br><span class="line">    if (faA !&#x3D; faB) &#123;</span><br><span class="line">        father[faA] &#x3D; faB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init(int n)&#123;&#x2F;&#x2F;初始化father[i]为i，且isRoot[i]为false</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        father[i] &#x3D; i;</span><br><span class="line">        isRoot[i] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">bool cmp(int a, int b)&#123;</span><br><span class="line">    return a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, k, h;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    init(n);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d:&quot;, &amp;k);</span><br><span class="line">        for (int j &#x3D; 0; j &lt; k; j++) &#123;&#x2F;&#x2F;对每个活动</span><br><span class="line">            scanf(&quot;%d&quot;, &amp;h);</span><br><span class="line">            if (course[h] &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F;h活动第一次有人喜欢</span><br><span class="line">                course[h] &#x3D; i;&#x2F;&#x2F;记录那个人的名字</span><br><span class="line">            &#125;</span><br><span class="line">            Union(i, findFather(course[h]));&#x2F;&#x2F;合并</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        isRoot[findFather(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        if (isRoot[i]) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    sort(isRoot + 1, isRoot + n + 1, cmp);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; ans; i++) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, isRoot[i]);</span><br><span class="line">        if (i &lt; ans) &#123;</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/24/218/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/24/218/" class="post-title-link" itemprop="url">好朋友 - 并查集</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-02-24 10:30:49 / 修改时间：10:33:27" itemprop="dateCreated datePublished" datetime="2017-02-24T10:30:49+00:00">2017-02-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">笔记</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>输入格式<br>    输入的第一行有两个正整数n &lt;=100 和m &lt;= 100，分别表示数码宝贝的个数和好朋友的组数，其中数码宝贝的编号为1~n。<br>    接下来有m行，每行两个正整数a和b，表示数码宝贝a和数码宝贝b是好朋友<br>输出格式<br>    输出一个整数，表示这些数码宝贝可以分成的组数。</p>
<p>样例输入1<br>4 2<br>1 4<br>2 3<br>样例输出1<br>2<br>样例输入2<br>7 5<br>1 2<br>2 3<br>3 1<br>1 4<br>5 6<br>样例输出2<br>3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;set&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;typedef long long LL;</span><br><span class="line">const int maxn&#x3D; 110;</span><br><span class="line">int father[maxn];&#x2F;&#x2F;存放父亲结点</span><br><span class="line">bool isRoot[maxn];&#x2F;&#x2F;记录每个结点是否作为某个集合的根结点</span><br><span class="line">int findFather(int x)&#123;&#x2F;&#x2F;查找x所在集合的根节点</span><br><span class="line">    int a &#x3D; x;</span><br><span class="line">    while (x !&#x3D; father[x]) &#123;</span><br><span class="line">        x &#x3D; father[x];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;路径压缩</span><br><span class="line">    while (a !&#x3D; father[a]) &#123;</span><br><span class="line">        int z &#x3D; a;</span><br><span class="line">        a &#x3D; father[a];</span><br><span class="line">        father[z] &#x3D; x;</span><br><span class="line">    &#125;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br><span class="line">void Union(int a, int b)&#123;&#x2F;&#x2F;合并a和b所在的集合</span><br><span class="line">    int faA &#x3D; findFather(a);</span><br><span class="line">    int faB &#x3D; findFather(b);</span><br><span class="line">    if (faA !&#x3D; faB) &#123;</span><br><span class="line">        father[faA] &#x3D; faB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void init(int n)&#123;&#x2F;&#x2F;初始化father[i]为i，且isRoot[i]为false</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        father[i] &#x3D; i;</span><br><span class="line">        isRoot[i] &#x3D; false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, m, a, b;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    init(n);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);</span><br><span class="line">        Union(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        isRoot[findFather(i)] &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    int ans &#x3D; 0;&#x2F;&#x2F;记录集合数目</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        ans +&#x3D; isRoot[i];</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/23/216/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/23/216/" class="post-title-link" itemprop="url">PAT A1066</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-02-23 19:47:36 / 修改时间：22:54:26" itemprop="dateCreated datePublished" datetime="2017-02-23T19:47:36+00:00">2017-02-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.<br><img data-src="https://www.patest.cn/upload/79_mtxjq1kj3gx.jpg" alt="请输入图片描述"><br><img data-src="https://www.patest.cn/upload/79_mtxjqnwja2o.jpg" alt="请输入图片描述"><br><img data-src="https://www.patest.cn/upload/79_mtxjr4gyzdg.jpg" alt="请输入图片描述"><br><img data-src="https://www.patest.cn/upload/79_mtxjrh51o9y.jpg" alt="请输入图片描述"><br>Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each test case, print ythe root of the resulting AVL tree in one line.</p>
<p>Sample Input 1:<br>5<br>88 70 61 96 120<br>Sample Output 1:<br>70<br>Sample Input 2:<br>7<br>88 70 61 96 120 90 65<br>Sample Output 2:<br>88</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;set&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;typedef long long LL;</span><br><span class="line">struct node &#123;</span><br><span class="line">    int v, height;&#x2F;&#x2F;v为结点权值，height为当前子树高度</span><br><span class="line">    node *lchild,*rchild;</span><br><span class="line">&#125; *root, *null;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;生成一个新结点，v为结点权值</span><br><span class="line">node* newNode(int v)&#123;</span><br><span class="line">    node* Node &#x3D; new node;</span><br><span class="line">    Node-&gt;v &#x3D; v;</span><br><span class="line">    Node-&gt;height &#x3D; 1;</span><br><span class="line">    Node-&gt;lchild &#x3D; Node-&gt;rchild &#x3D; NULL;</span><br><span class="line">    return Node;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;获取以root为根的子树当前的高度height</span><br><span class="line">int getHeight(node* root)&#123;</span><br><span class="line">    if (root &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return root-&gt;height;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;更新结点root的height</span><br><span class="line">void updateHeight(node* root)&#123;</span><br><span class="line">    &#x2F;&#x2F;max+1</span><br><span class="line">    root-&gt;height &#x3D; max(getHeight(root-&gt;lchild), getHeight(root-&gt;rchild)) + 1;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;计算结点root的平衡因子</span><br><span class="line">int getBalance(node* root)&#123;</span><br><span class="line">    return getHeight(root-&gt;lchild) - getHeight(root-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;左旋</span><br><span class="line">void L(node* &amp;root)&#123;</span><br><span class="line">    node* temp &#x3D; root-&gt;rchild;</span><br><span class="line">    root-&gt;rchild &#x3D; temp-&gt;lchild;</span><br><span class="line">    temp-&gt;lchild &#x3D; root;</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;右旋</span><br><span class="line">void R(node* &amp;root)&#123;</span><br><span class="line">    node* temp &#x3D; root-&gt;lchild;</span><br><span class="line">    root-&gt;lchild &#x3D; temp-&gt;rchild;</span><br><span class="line">    temp-&gt;rchild &#x3D; root;</span><br><span class="line">    updateHeight(root);</span><br><span class="line">    updateHeight(temp);</span><br><span class="line">    root &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;插入权值为v的结点</span><br><span class="line">void insert(node* &amp;root, int v)&#123;</span><br><span class="line">    if (root &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        root &#x3D; newNode(v);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (v &lt; root-&gt;v) &#123;</span><br><span class="line">        insert(root-&gt;lchild, v);&#x2F;&#x2F;往左子树插入</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        if (getBalance(root) &#x3D;&#x3D; 2) &#123;</span><br><span class="line">            if (getBalance(root-&gt;lchild) &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F;LL</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;else if(getBalance(root-&gt;lchild) &#x3D;&#x3D; -1)&#123;&#x2F;&#x2F;LR</span><br><span class="line">                L(root-&gt;lchild);</span><br><span class="line">                R(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        insert(root-&gt;rchild, v);&#x2F;&#x2F;往右子树插入</span><br><span class="line">        updateHeight(root);</span><br><span class="line">        if (getBalance(root) &#x3D;&#x3D; -2) &#123;</span><br><span class="line">            if (getBalance(root-&gt;rchild) &#x3D;&#x3D; -1) &#123;&#x2F;&#x2F;RR</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;else if(getBalance(root-&gt;rchild) &#x3D;&#x3D; 1)&#123;&#x2F;&#x2F;RL</span><br><span class="line">                R(root-&gt;rchild);</span><br><span class="line">                L(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, v;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i &#x3D; 0 ; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;v);</span><br><span class="line">        insert(root, v);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, root-&gt;v);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">何米酥</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  


















  








    <div class="pjax">
  

  

    </div>
</body>
</html>
