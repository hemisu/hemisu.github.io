<!DOCTYPE html>
<html lang="zh-CN,en,default">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.hemisu.com","root":"/","scheme":"Gemini","version":"8.0.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":true,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}};
  </script>

  <meta name="description" content="Just do...">
<meta property="og:type" content="website">
<meta property="og:title" content="何米酥&#96;s Blog">
<meta property="og:url" content="http://www.hemisu.com/page/6/index.html">
<meta property="og:site_name" content="何米酥&#96;s Blog">
<meta property="og:description" content="Just do...">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="何米酥">
<meta property="article:tag" content="web, 前端, 生活, 分享">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://www.hemisu.com/page/6/">


<script data-pjax class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>何米酥`s Blog</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">何米酥`s Blog</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">EFE</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">何米酥</p>
  <div class="site-description" itemprop="description">Just do...</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">203</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">80</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hemisu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hemisu" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/hemisu" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;hemisu" rel="noopener" target="_blank"><i class="globe fa-fw"></i>知乎</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">
      

      
    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/03/01/248/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/01/248/" class="post-title-link" itemprop="url">2.28模拟题 problem4 调查黑暗气息</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-03-01 13:00:00 / 修改时间：13:57:43" itemprop="dateCreated datePublished" datetime="2017-03-01T13:00:00+00:00">2017-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在数码世界中有一个叫做“Radiation Zone”的区域，里面荒无人烟，仿佛遗迹一般。在这个区域中有N个城市（假设编号为从0到N-1），每个城市中都有一定数量的辐能。有M条已知长度的道路连接它们，每条道路都可以双向来往。</p>
<p>近期这个区域似有黑暗气息蛰伏，国王Shoutmon派出调查队前来调查这个区域中的城市。调查队的飞船降落在S号城市。由于飞船降落时气流不稳定，因此产生了辐能波，导致以S号城市为中心的L层以内（假设S号城市为最内层，记为第0层）的城市的辐能都会上升（只上升一次），上升的数值为 “城市的当前辐能乘以百分比p”的向上取整。其中百分比p在S号城市时为100%，且每向外扩散一层，百分比降低100%/L（例如，如果L为5，那么第0层（即S号城市）为100%，第1层为80%，第2层为60%，第3层为40%，第4层为20%，其中百分比均为浮点数）。所谓第X层是指，连接某城市与S号城市的最少数量的道路数，例如下图是一个例子，图中的数字为其层号。</p>
<p><img data-src="http://shoutmon.qiniudn.com/pic.png" alt="图片"></p>
<p>之后调查队需要前往T号城市调查。为了顺便清除城市中的辐能，他们准备了一个容量为K的辐能吸收器。辐能吸收器可以自动吸收城市中的辐能，且满容量时会自动将容器内的所有辐能都燃烧完毕，以继续吸收辐能。假设调查队总是把城市（含S号和T号城市）中的辐能吸收完毕。</p>
<p>为了节省体力，调查队希望选择一条长度最短的路径前往T号城市；如果这样的路径有多条，那么从中选择到达T号城市时辐能吸收器内当前辐能最大的路径；如果这样的路径仍然有多条，那么从中选择路径后半段的城市的辐能之和最小的路径（所谓后半段是指，如果路径上有m个城市，那么后m/2个城市（含T号城市）是后半段的城市。例如，如果路径上有7个城市，那么路径的后3个城市（除法为向下取整）为后半段的城市）。数据保证这样的路径一定唯一。</p>
<p>输入<br>每个输入文件中一组数据。</p>
<p>第一行六个整数N、M、L、K、S、T（2&lt;=N&lt;=500, M&lt;=N*(N-1)/2, 1&lt;=L&lt;=500, 2&lt;=K&lt;=100, S != T），分别代表城市个数、道路条数、辐能上升的层数、辐能吸收器的容量、起点城市编号、终点城市编号。</p>
<p>接下来一行有N个正整数，分别给出N个城市的初始辐能（均为不超过100的正整数）。</p>
<p>接下来M行，每行三个数字u、v、w，代表一条道路，其中u和v为道路的两个端点城市编号，w为道路的长度（w为不超过1000的正整数）。数据保证u不等于v，且相同的无序对(u,v)只出现一次。</p>
<p>输出<br>如果从S号城市不能到达T号城市，那么只输出-1。</p>
<p>如果从S号城市能到达T号城市，那么输出两行：</p>
<p>第一行输出四个整数， 即S号城市到T号城市的最短距离的路径条数（数据保证不超过100000条）、S号城市到T号城市的最短距离、通过最终选择的路径到达T号城市时辐能吸收器内的当前辐能、最终选择的路径的后半段城市的辐能之和。</p>
<p>第二行输出最终选择的路径，路径上的城市之间用-&gt;隔开。</p>
<p>样例输入<br>7 8 1 7 0 6<br>20 10 10 6 8 13 5<br>0 1 1<br>0 2 1<br>1 3 1<br>2 4 1<br>2 5 1<br>3 6 1<br>4 6 1<br>5 6 1<br>样例输出<br>3 3 5 11<br>0-&gt;1-&gt;3-&gt;6<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">&#x2F;&#x2F;N、M、L、K、S、T（2&lt;&#x3D;N&lt;&#x3D;500, M&lt;&#x3D;N*(N-1)&#x2F;2, 1&lt;&#x3D;L&lt;&#x3D;500, 2&lt;&#x3D;K&lt;&#x3D;100, S !&#x3D; T），分别代表城市个数、道路条数、辐能上升的层数、辐能吸收器的容量、起点城市编号、终点城市编号</span><br><span class="line">const int maxn &#x3D; 510;</span><br><span class="line">const int INF &#x3D; 1000000000;</span><br><span class="line">int n, m, l, k, s, t;</span><br><span class="line">int weight[maxn], G[maxn][maxn], d[maxn];</span><br><span class="line">int numPath &#x3D; 0, remainK &#x3D; -1, halfSumK &#x3D; INF;</span><br><span class="line">bool inq[maxn] &#x3D; &#123;false&#125;, vis[maxn] &#x3D; &#123;false&#125;;</span><br><span class="line">vector&lt;int&gt; tempPath, path;</span><br><span class="line">vector&lt;int&gt; pre[maxn];</span><br><span class="line">struct node&#123;</span><br><span class="line">    int layer;&#x2F;&#x2F;层数</span><br><span class="line">    int id;</span><br><span class="line">&#125;;</span><br><span class="line">void init()&#123;</span><br><span class="line">    fill(G[0], G[0]+ maxn * maxn, INF);</span><br><span class="line">    numPath &#x3D; 0;</span><br><span class="line">    remainK &#x3D; -1;</span><br><span class="line">    halfSumK &#x3D; INF;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    memset(inq, false, sizeof(inq));</span><br><span class="line">    for (int i &#x3D; 0; i &lt; maxn; i++) &#123;</span><br><span class="line">        pre[i].clear();</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.clear();</span><br><span class="line">    path.clear();</span><br><span class="line">&#125;</span><br><span class="line">void DFS(int v)&#123;</span><br><span class="line">    if (v &#x3D;&#x3D; s) &#123;</span><br><span class="line">        tempPath.push_back(v);</span><br><span class="line">        numPath++;</span><br><span class="line">        int tempW &#x3D; 0, temphalfSumK &#x3D; 0;</span><br><span class="line">        for (int i &#x3D; 0; i &lt; (int)tempPath.size() &#x2F; 2; i++) &#123;</span><br><span class="line">            int id &#x3D; tempPath[i];</span><br><span class="line">            tempW +&#x3D; weight[id];</span><br><span class="line">            temphalfSumK +&#x3D; weight[id];</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i &#x3D; (int)tempPath.size() &#x2F; 2; i &lt; tempPath.size(); i++) &#123;</span><br><span class="line">            int id &#x3D; tempPath[i];</span><br><span class="line">            tempW +&#x3D; weight[id];</span><br><span class="line">        &#125;</span><br><span class="line">        if (tempW % k &gt; remainK) &#123;</span><br><span class="line">            remainK &#x3D; tempW % k;</span><br><span class="line">            halfSumK &#x3D; temphalfSumK;</span><br><span class="line">            path &#x3D; tempPath;</span><br><span class="line">        &#125;else if(tempW % k &#x3D;&#x3D; remainK )&#123;</span><br><span class="line">            if (temphalfSumK &lt; halfSumK) &#123;</span><br><span class="line">                halfSumK &#x3D; temphalfSumK;</span><br><span class="line">                path &#x3D; tempPath;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.push_back(v);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; pre[v].size(); i++) &#123;</span><br><span class="line">        DFS(pre[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line">void Dijstra(int s)&#123;</span><br><span class="line">    fill(d, d + maxn, INF);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        pre[i].push_back(i);&#x2F;&#x2F;初始化路径</span><br><span class="line">    &#125;</span><br><span class="line">    d[s] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        int u &#x3D; -1, MIN &#x3D; INF;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (vis[j] &#x3D;&#x3D; false &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u &#x3D; j;</span><br><span class="line">                MIN &#x3D; d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (u &#x3D;&#x3D; -1) return;</span><br><span class="line">        vis[u] &#x3D; true;</span><br><span class="line">        for (int v &#x3D; 0; v &lt; n; v++) &#123;</span><br><span class="line">            if (vis[v] &#x3D;&#x3D; false &amp;&amp; G[u][v] !&#x3D; INF) &#123;</span><br><span class="line">                if (d[u] + G[u][v] &lt; d[v] ) &#123;</span><br><span class="line">                    d[v] &#x3D; d[u] + G[u][v];</span><br><span class="line">                    pre[v].clear();</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;else if(d[u] + G[u][v] &#x3D;&#x3D; d[v])&#123;</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void BFS(int s)&#123;&#x2F;&#x2F;BFS解决污染扩散问题</span><br><span class="line">    node start;</span><br><span class="line">    start.id &#x3D; s;</span><br><span class="line">    start.layer &#x3D; 0;</span><br><span class="line">    queue&lt;node&gt; q;</span><br><span class="line">    q.push(start);</span><br><span class="line">    inq[start.id] &#x3D; true;</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        node now &#x3D; q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        int u &#x3D; now.id;</span><br><span class="line">        if (now.layer &lt; l) &#123;</span><br><span class="line">            weight[u] +&#x3D; (int)(ceil(weight[u] * 1.0 * (l - now.layer) &#x2F; l ) + 0.5);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int v &#x3D; 0; v &lt; n; v++) &#123;</span><br><span class="line">            if (inq[v] &#x3D;&#x3D; false &amp;&amp; G[u][v] !&#x3D; INF) &#123;</span><br><span class="line">                node next;</span><br><span class="line">                next.id &#x3D; v;</span><br><span class="line">                next.layer &#x3D; now.layer + 1;</span><br><span class="line">                q.push(next);</span><br><span class="line">                inq[v] &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    scanf(&quot;%d%d%d%d%d%d&quot;, &amp;n, &amp;m, &amp;l, &amp;k, &amp;s, &amp;t);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;weight[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int u, v, w;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d%d&quot;, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        G[u][v] &#x3D; G[v][u] &#x3D; w;</span><br><span class="line">    &#125;</span><br><span class="line">    BFS(s);</span><br><span class="line">    if(inq[t] &#x3D;&#x3D; false)&#123;</span><br><span class="line">        printf(&quot;-1\n&quot;);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    Dijstra(s);</span><br><span class="line">    DFS(t);        &#x2F;&#x2F;获取最优路径</span><br><span class="line">    printf(&quot;%d %d %d %d\n&quot;, numPath, d[t], remainK, halfSumK);</span><br><span class="line">    for(int i &#x3D; path.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, path[i]);      &#x2F;&#x2F;倒着输出路径上的结点</span><br><span class="line">        if(i &gt; 0) printf(&quot;-&gt;&quot;);</span><br><span class="line">        else printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/03/01/247/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/01/247/" class="post-title-link" itemprop="url">2.28模拟题 problem1 判断三角形</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-03-01 10:38:35" itemprop="dateCreated datePublished" datetime="2017-03-01T10:38:35+00:00">2017-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>题目描述<br>Shoutmon给萌萌兽出了一个题：给出三条线段的长度，问能否组成三角形。不过线段的长度是通过每一个数位的英文给出的。你能帮助萌萌兽吗？</p>
<p>输入<br>每个输入文件中一组数据。</p>
<p>分三行分别给出三条线段的长度。每行以一个整数N（1&lt;=N&lt;=5）开始，表示后面给出的单词个数；接下来跟着N个英文单词，每个单词表示一个数位，线段的长度由这些英文单词直接拼接而成（例如one two three代表123，one one代表11），每两个单词之间用一个空格隔开。数字0到9分别用下面十个单词表示：zero、one、two、three、four、five、six、seven、eight、nine。数据保证每条线段的长度都不为0。</p>
<p>输出<br>如果可以组成三角形，那么输出YES；否则输出NO。</p>
<p>样例输入<br>1 one<br>2 one one<br>3 one one one<br>样例输出<br>NO<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">string numcode[] &#x3D; &#123;&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;, &quot;eight&quot;, &quot;nine&quot;&#125;;</span><br><span class="line">map&lt;string, int&gt; strToNum;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int tri[3];</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">        strToNum[numcode[i]] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">        int k, number &#x3D; 0;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;k);</span><br><span class="line">        for (int j &#x3D; 0; j &lt; k; j++) &#123;</span><br><span class="line">            char temp[10];</span><br><span class="line">            scanf(&quot;%s&quot;, temp);</span><br><span class="line">            number &#x3D; number * 10 + strToNum[temp];</span><br><span class="line">        &#125;</span><br><span class="line">        tri[i] &#x3D; number;</span><br><span class="line">    &#125;</span><br><span class="line">    if(tri[0] + tri[1] &gt; tri[2] &amp;&amp;</span><br><span class="line">       tri[1] + tri[2] &gt; tri[0] &amp;&amp;</span><br><span class="line">       tri[0] + tri[2] &gt; tri[1] )&#123;</span><br><span class="line">        printf(&quot;YES\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;NO\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/03/01/245/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/01/245/" class="post-title-link" itemprop="url">2.28模拟题 problem3 还原二叉树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-03-01 10:22:04 / 修改时间：10:22:25" itemprop="dateCreated datePublished" datetime="2017-03-01T10:22:04+00:00">2017-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>题目描述<br>给一棵二叉树的层序遍历序列和中序遍历序列，求这棵二叉树的先序遍历序列和后序遍历序列。</p>
<p>输入<br>每个输入文件中一组数据。</p>
<p>第一行一个正整数N（1&lt;=N&lt;=30），代表二叉树的结点个数（结点编号为1~N）。接下来两行，每行N个正整数，分别代表二叉树的层序遍历序列和中序遍历序列。数据保证序列中1~N的每个数出现且只出现一次。</p>
<p>输出<br>输出两行，每行N个正整数，分别代表二叉树的先序遍历序列和后序遍历序列。每行末尾不输出额外的空格。</p>
<p>样例输入<br>7<br>3 5 4 2 6 7 1<br>2 5 3 6 4 7 1<br>样例输出<br>3 5 2 4 6 7 1<br>2 5 6 1 7 4 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 50;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int data;</span><br><span class="line">    node *lchild, *rchild;</span><br><span class="line">&#125;;</span><br><span class="line">int n, lev[maxn], in[maxn];</span><br><span class="line">vector&lt;int&gt; layer, pre, post;</span><br><span class="line">node* createTree(vector&lt;int&gt; layer, int inL, int inR)&#123;</span><br><span class="line">    if (layer.size() &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    node* root &#x3D; new node;</span><br><span class="line">    root-&gt;data &#x3D; layer[0];</span><br><span class="line">    int k;</span><br><span class="line">    for (k &#x3D; inL; k &lt;&#x3D; inR; k++) &#123;</span><br><span class="line">        if (layer[0] &#x3D;&#x3D; in[k]) &#123;&#x2F;&#x2F;在中序遍历中找到</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;int&gt; layerLeft;</span><br><span class="line">    vector&lt;int&gt; layerRight;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; layer.size(); i++) &#123;</span><br><span class="line">        bool isLeft &#x3D; false;</span><br><span class="line">        for (int j &#x3D; inL; j &lt; k; j++) &#123;</span><br><span class="line">            if (layer[i] &#x3D;&#x3D; in[j]) &#123;</span><br><span class="line">                isLeft &#x3D; true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (isLeft) &#123;</span><br><span class="line">            layerLeft.push_back(layer[i]);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            layerRight.push_back(layer[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;lchild &#x3D; createTree(layerLeft, inL, k - 1);</span><br><span class="line">    root-&gt;rchild &#x3D; createTree(layerRight, k + 1, inR);</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">void preOrder(node* root, vector&lt;int&gt; &amp;vi) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    vi.push_back(root-&gt;data);</span><br><span class="line">    preOrder(root-&gt;lchild, vi);</span><br><span class="line">    preOrder(root-&gt;rchild, vi);</span><br><span class="line">&#125;</span><br><span class="line">void postOrder(node* root, vector&lt;int&gt; &amp;vi) &#123;</span><br><span class="line">    if (root &#x3D;&#x3D; NULL) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root-&gt;lchild, vi);</span><br><span class="line">    postOrder(root-&gt;rchild, vi);</span><br><span class="line">    vi.push_back(root-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;lev[i]);</span><br><span class="line">        layer.push_back(lev[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;in[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    node* root &#x3D; NULL;</span><br><span class="line">    root &#x3D; createTree(layer, 0, n - 1);</span><br><span class="line">    preOrder(root, pre);</span><br><span class="line">    postOrder(root, post);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, pre[i]);</span><br><span class="line">        if (i &lt; n - 1) printf(&quot; &quot;);</span><br><span class="line">        else printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, post[i]);</span><br><span class="line">        if (i &lt; n - 1) printf(&quot; &quot;);</span><br><span class="line">        else printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/03/01/244/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/03/01/244/" class="post-title-link" itemprop="url">2.28模拟题 problem2 进击的二叉查找树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-03-01 09:43:48 / 修改时间：09:44:29" itemprop="dateCreated datePublished" datetime="2017-03-01T09:43:48+00:00">2017-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>题目描述<br>给定1~N的两个排列，使用这两个排列分别构建两棵二叉查找树（也就是通过往一棵空树中依次插入序列元素的构建方式）。如果这两棵二叉查找树完全相同，那么输出YES；否则输出NO。之后，输出第一个排列对应的二叉查找树的后序序列、层序序列。</p>
<p>输入<br>每个输入文件中一组数据。</p>
<p>第一行1个正整数N（1&lt;=N&lt;=30），表示二叉查找树中的结点个数。</p>
<p>接下来两行，代表1~N的两个排列。</p>
<p>输出<br>如果两个排列代表的二叉查找树完全相同，那么输出一行YES，否则输出一行NO。</p>
<p>接下来两行分别输出第一个排列对应的二叉查找树的后序序列、层序序列，整数之间用空格隔开。</p>
<p>每行末尾不允许有多余的空格。</p>
<p>样例输入<br>5<br>4 2 1 3 5<br>4 5 2 3 1<br>样例输出<br>YES<br>1 3 2 5 4<br>4 2 5 1 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int maxn &#x3D; 40;</span><br><span class="line">struct node&#123;</span><br><span class="line">    int data;</span><br><span class="line">    int lchild;</span><br><span class="line">    int rchild;</span><br><span class="line">&#125;Node[maxn * 2];</span><br><span class="line">int nodenum &#x3D; 0;</span><br><span class="line">int n;</span><br><span class="line">vector&lt;int&gt; post1, post2, lev1;</span><br><span class="line">int newNode(int x)&#123;</span><br><span class="line">    Node[nodenum].data &#x3D; x;</span><br><span class="line">    Node[nodenum].lchild &#x3D; -1;</span><br><span class="line">    Node[nodenum].rchild &#x3D; -1;</span><br><span class="line">    return nodenum++;</span><br><span class="line">&#125;</span><br><span class="line">void insert(int &amp;root, int x)&#123;</span><br><span class="line">    if (root &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        root &#x3D; newNode(x);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &lt; Node[root].data) &#123;</span><br><span class="line">        insert(Node[root].lchild, x);</span><br><span class="line">    &#125;</span><br><span class="line">    if (x &gt; Node[root].data) &#123;</span><br><span class="line">        insert(Node[root].rchild, x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int createTree(int arr[])&#123;</span><br><span class="line">    int root &#x3D; -1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        insert(root, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line">void post(int root, vector&lt;int&gt;&amp; vi)&#123;</span><br><span class="line">    if (root &#x3D;&#x3D; -1) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    post(Node[root].lchild, vi);</span><br><span class="line">    post(Node[root].rchild, vi);</span><br><span class="line">    vi.push_back(Node[root].data);</span><br><span class="line">&#125;</span><br><span class="line">void lev(int root, vector&lt;int&gt;&amp; vi)&#123;</span><br><span class="line">    queue&lt;int&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    while (!q.empty()) &#123;</span><br><span class="line">        int now &#x3D; q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        vi.push_back(Node[now].data);</span><br><span class="line">        if (Node[now].lchild !&#x3D; -1) q.push(Node[now].lchild);</span><br><span class="line">        if (Node[now].rchild !&#x3D; -1) q.push(Node[now].rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int str1[maxn], str2[maxn];</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;str1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int root1 &#x3D; createTree(str1);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;str2[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    int root2 &#x3D; createTree(str2);</span><br><span class="line">    post(root1, post1);</span><br><span class="line">    post(root2, post2);</span><br><span class="line">    lev(root1, lev1);</span><br><span class="line">    if (post1 &#x3D;&#x3D; post2) &#123;</span><br><span class="line">        printf(&quot;YES\n&quot;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        printf(&quot;NO\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, post1[i]);</span><br><span class="line">        if(i &lt; n - 1)printf(&quot; &quot;);</span><br><span class="line">        else printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        printf(&quot;%d&quot;, lev1[i]);</span><br><span class="line">        if(i &lt; n - 1)printf(&quot; &quot;);</span><br><span class="line">        else printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/28/243/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/28/243/" class="post-title-link" itemprop="url">PAT A1040 . Longest Symmetric String (25)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-02-28 11:09:12 / 修改时间：17:59:49" itemprop="dateCreated datePublished" datetime="2017-02-28T11:09:12+00:00">2017-02-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Given a string, you are supposed to output the length of the longest symmetric sub-string. For example, given “Is PAT&amp;TAP symmetric?”, the longest symmetric sub-string is “s PAT&amp;TAP s”, hence you must output 11.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case which gives a non-empty string of length no more than 1000.</p>
<p>Output Specification:</p>
<p>For each test case, simply print the maximum length in a line.</p>
<p>Sample Input:<br>Is PAT&amp;TAP symmetric?<br>Sample Output:<br>11<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;vector&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;set&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 1010;</span><br><span class="line">char S[maxn];</span><br><span class="line">int dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    gets(S);</span><br><span class="line">    int len &#x3D; strlen(S), ans &#x3D; 1;</span><br><span class="line">    memset(dp, 0, sizeof(S));</span><br><span class="line">    &#x2F;&#x2F;边界</span><br><span class="line">    for (int i &#x3D; 0; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i][i] &#x3D; 1;</span><br><span class="line">        if (i &lt; len - 1) &#123;</span><br><span class="line">            if (S[i] &#x3D;&#x3D; S[i + 1]) &#123;</span><br><span class="line">                dp[i][i + 1] &#x3D; 1;</span><br><span class="line">                ans &#x3D; 2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;状态转移方程</span><br><span class="line">    for (int L &#x3D; 3; L &lt;&#x3D; len; L++) &#123;</span><br><span class="line">        for (int i &#x3D; 0; i + L - 1 &lt; len; i++) &#123;&#x2F;&#x2F;枚举子串的起始结点</span><br><span class="line">            int j &#x3D; i + L - 1;&#x2F;&#x2F;子串右结点</span><br><span class="line">            if (S[i] &#x3D;&#x3D; S[j] &amp;&amp; dp[i + 1][j - 1] &#x3D;&#x3D; 1) &#123;</span><br><span class="line">                dp[i][j] &#x3D; 1;</span><br><span class="line">                ans &#x3D; L;&#x2F;&#x2F;更新最长回文子串长度</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/27/240/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/27/240/" class="post-title-link" itemprop="url">PAT A1045 . Favorite Color Stripe (30)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-02-27 20:00:00" itemprop="dateCreated datePublished" datetime="2017-02-27T20:00:00+00:00">2017-02-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2017-02-28 10:55:12" itemprop="dateModified" datetime="2017-02-28T10:55:12+00:00">2017-02-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Eva is trying to make her own color stripe out of a given one. She would like to keep only her favorite colors in her favorite order by cutting off those unwanted pieces and sewing the remaining parts together to form her favorite color stripe.</p>
<p>It is said that a normal human eye can distinguish about less than 200 different colors, so Eva’s favorite colors are limited. However the original stripe could be very long, and Eva would like to have the remaining favorite stripe with the maximum length. So she needs your help to find her the best result.</p>
<p>Note that the solution might not be unique, but you only have to tell her the maximum length. For example, given a stripe of colors {2 2 4 1 5 5 6 3 1 1 5 6}. If Eva’s favorite colors are given in her favorite order as {2 3 1 5 6}, then she has 4 possible best solutions {2 2 1 1 1 5 6}, {2 2 1 5 5 5 6}, {2 2 1 5 5 6 6}, and {2 2 3 1 1 5 6}.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains a positive integer N (&lt;=200) which is the total number of colors involved (and hence the colors are numbered from 1 to N). Then the next line starts with a positive integer M (&lt;=200) followed by M Eva’s favorite color numbers given in her favorite order. Finally the third line starts with a positive integer L (&lt;=10000) which is the length of the given stripe, followed by L colors on the stripe. All the numbers in a line are separated by a space.</p>
<p>Output Specification:</p>
<p>For each test case, simply print in a line the maximum length of Eva’s favorite stripe.</p>
<p>Sample Input:<br>6<br>5 2 3 1 5 6<br>12 2 2 4 1 5 5 6 3 1 1 5 6<br>Sample Output:<br>7</p>
<p>lis:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int maxc &#x3D; 210;&#x2F;&#x2F;最大颜色数</span><br><span class="line">const int maxn &#x3D; 10010;&#x2F;&#x2F;最大L</span><br><span class="line">int hashTable[maxc];&#x2F;&#x2F;将最喜欢的颜色序列映射为递增序列，不喜欢的颜色映射为-1</span><br><span class="line">int A[maxn], dp[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, m, x;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    memset(hashTable, -1, sizeof(hashTable));</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">        hashTable[x] &#x3D; i;</span><br><span class="line">    &#125;</span><br><span class="line">    int L, num &#x3D; 0;&#x2F;&#x2F;num存放颜色序列中eva最喜欢的颜色的总数</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;L);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; L; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;x);</span><br><span class="line">        if (hashTable[x] &gt;&#x3D; 0) &#123;&#x2F;&#x2F;若有喜欢的颜色，添加到数组A中</span><br><span class="line">            A[num++] &#x3D; hashTable[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;以下全部为LIS问题模板</span><br><span class="line">    int ans &#x3D; -1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; num; i++) &#123;</span><br><span class="line">        dp[i] &#x3D; 1;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (A[j] &lt;&#x3D; A[i] &amp;&amp; dp[i] &lt; dp[j] + 1) &#123;</span><br><span class="line">                dp[i] &#x3D; dp[j] + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans &#x3D; max(ans, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>lcs:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line"></span><br><span class="line">const int maxc &#x3D; 210;</span><br><span class="line">const int maxn &#x3D; 1000010;</span><br><span class="line">int a[maxc], b[maxn], dp[maxc][maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">    int n, m;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; m ; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);&#x2F;&#x2F;读入序列A</span><br><span class="line">    &#125;</span><br><span class="line">    int L;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;L);</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; L; i++) &#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;边界</span><br><span class="line">    for (int i &#x3D; 0; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">        dp[i][0] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int j &#x3D; 0; j &lt;&#x3D; L; j++) &#123;</span><br><span class="line">        dp[0][j] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;状态转移方程</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; m; i++) &#123;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; L; j++) &#123;</span><br><span class="line">            &#x2F;&#x2F;取dp[i-1][j]、dp[i][j-1]中的较大值</span><br><span class="line">            int MAX &#x3D; max(dp[i - 1][j], dp[i][j - 1]);</span><br><span class="line">            if (a[i] &#x3D;&#x3D; b[j]) &#123;</span><br><span class="line">                dp[i][j] &#x3D; MAX + 1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i][j] &#x3D; MAX;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;输出答案</span><br><span class="line">    printf(&quot;%d\n&quot;, dp[m][L]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/27/238/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/27/238/" class="post-title-link" itemprop="url">PAT A1007 . Maximum Subsequence Sum (25)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-02-27 19:06:00" itemprop="dateCreated datePublished" datetime="2017-02-27T19:06:00+00:00">2017-02-27</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2017-02-28 10:32:13" itemprop="dateModified" datetime="2017-02-28T10:32:13+00:00">2017-02-28</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Given a sequence of K integers { N<sub>1</sub>, N<sub>2</sub>, …, N<sub>K</sub> }. A continuous subsequence is defined to be { N<sub>i</sub>, N<sub>i+1</sub>, …, N<sub>j</sub> } where 1 &lt;= i &lt;= j &lt;= K. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p>
<p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer K (&lt;= 10000). The second line contains K numbers, separated by a space.</p>
<p>Output Specification:</p>
<p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices i and j (as shown by the sample case). If all the K numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p>
<p>Sample Input:<br>10<br>-10 1 2 3 4 -5 -23 3 7 -21<br>Sample Output:<br>10 1 4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line"></span><br><span class="line">const int maxn &#x3D; 10010;</span><br><span class="line">int a[maxn], dp[maxn];</span><br><span class="line">int s[maxn] &#x3D; &#123;0&#125;;&#x2F;&#x2F;s[i]表示dp[i]的连续序列从a的哪一个元素开始</span><br><span class="line">    </span><br><span class="line">int main()&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;n);</span><br><span class="line">    bool flag &#x3D; false;&#x2F;&#x2F;flag表示数组a中是否全小于0</span><br><span class="line">    for(int i &#x3D; 0; i &lt; n; i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;a[i]);</span><br><span class="line">        if (a[i] &gt;&#x3D; 0) flag &#x3D; true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (flag &#x3D;&#x3D; false) &#123;&#x2F;&#x2F;如果所有数字都小于0，则输出0以及尾首元素</span><br><span class="line">        printf(&quot;0 %d %d\n&quot;, a[0], a[n - 1]);</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;边界</span><br><span class="line">    dp[0] &#x3D; a[0];</span><br><span class="line">    for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">        &#x2F;&#x2F;状态转移方程</span><br><span class="line">        if (dp[i - 1] + a[i] &gt; a[i]) &#123;</span><br><span class="line">            dp[i] &#x3D; dp[i - 1] + a[i];</span><br><span class="line">            s[i] &#x3D; s[i - 1];</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            dp[i] &#x3D; a[i];</span><br><span class="line">            s[i] &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;因为dp[i]存放的是以a[i]结尾的连续序列的最大和</span><br><span class="line">    &#x2F;&#x2F;因此需要遍历i得到最大的才是结果</span><br><span class="line">    int k &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 1; i &lt; n; i++) &#123;</span><br><span class="line">        if (dp[i] &gt; dp[k]) &#123;</span><br><span class="line">            k &#x3D; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d %d %d\n&quot;, dp[k], a[s[k]], a[k]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/26/237/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/26/237/" class="post-title-link" itemprop="url">PAT A1087</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-02-26 15:51:03 / 修改时间：18:38:45" itemprop="dateCreated datePublished" datetime="2017-02-26T15:51:03+00:00">2017-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains 2 positive integers N (2&lt;=N&lt;=200), the number of cities, and K, the total number of routes between pairs of cities; followed by the name of the starting city. The next N-1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then K lines follow, each describes a route between two cities in the format “City1 City2 Cost”. Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome.</p>
<p>Output Specification:</p>
<p>For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommended. If such a route is still not unique, then we output the one with the maximum average happiness – it is guaranteed by the judge that such a solution exists and is unique.</p>
<p>Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommended route. Then in the next line, you are supposed to print the route in the format “City1-&gt;City2-&gt;…-&gt;ROM”.</p>
<p>Sample Input:<br>6 7 HZH<br>ROM 100<br>PKN 40<br>GDN 55<br>PRS 95<br>BLN 80<br>ROM GDN 1<br>BLN ROM 1<br>HZH PKN 1<br>PRS ROM 2<br>BLN HZH 2<br>PKN GDN 1<br>HZH PRS 1<br>Sample Output:<br>3 3 195 97<br>HZH-&gt;PRS-&gt;ROM</p>
<p>仅用dijstra：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &quot;set&quot;</span><br><span class="line">#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXV &#x3D; 410;&#x2F;&#x2F;最大顶点数</span><br><span class="line">const int INF &#x3D; 1000000000;&#x2F;&#x2F;无穷大</span><br><span class="line">&#x2F;&#x2F;n 城市数目, k 边数, G 邻接矩阵, w 点权</span><br><span class="line">&#x2F;&#x2F;d[]最短距离,dw[]最大点权,num[]最短路径条数</span><br><span class="line">&#x2F;&#x2F;pt[]记录最短路径上的顶点数,pre[]记录前驱</span><br><span class="line">int n, k, G[MAXV][MAXV], weight[MAXV];</span><br><span class="line">int d[MAXV], w[MAXV], num[MAXV], pt[MAXV], pre[MAXV];</span><br><span class="line">bool vis[MAXV] &#x3D; &#123;false&#125;;</span><br><span class="line">map&lt;string, int&gt; cityToIndex;</span><br><span class="line">map&lt;int, string&gt; indexToCity;</span><br><span class="line"></span><br><span class="line">void Dijkstra(int s)&#123;</span><br><span class="line">    fill(d, d + MAXV, INF);</span><br><span class="line">    memset(w, 0, sizeof(w));</span><br><span class="line">    memset(num, 0, sizeof(num));</span><br><span class="line">    memset(pt, 0, sizeof(pt));</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) pre[i] &#x3D; i;&#x2F;&#x2F;前驱初始化</span><br><span class="line">    d[s] &#x3D; 0;</span><br><span class="line">    w[s] &#x3D; 0;</span><br><span class="line">    num[s] &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;&#x2F;&#x2F;循环n次</span><br><span class="line">        int u &#x3D; -1, MIN &#x3D; INF;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (vis[j] &#x3D;&#x3D; false &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u &#x3D; j;</span><br><span class="line">                MIN &#x3D; d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (u &#x3D;&#x3D; -1) return;</span><br><span class="line">        vis[u] &#x3D; true;</span><br><span class="line">        for (int v &#x3D; 0; v &lt; n; v++) &#123;</span><br><span class="line">            if (vis[v] &#x3D;&#x3D; false &amp;&amp; G[u][v] !&#x3D; INF) &#123;</span><br><span class="line">                if (d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] &#x3D; d[u] + G[u][v];&#x2F;&#x2F;优化d[v]</span><br><span class="line">                    w[v] &#x3D; w[u] + weight[v];</span><br><span class="line">                    num[v] &#x3D; num[u];</span><br><span class="line">                    pt[v] &#x3D; pt[u] + 1;</span><br><span class="line">                    pre[v] &#x3D; u;</span><br><span class="line">                &#125;else if (d[u] + G[u][v] &#x3D;&#x3D; d[v])&#123;</span><br><span class="line">                    num[v] +&#x3D; num[u];&#x2F;&#x2F;加最短路径条数</span><br><span class="line">                    if (w[u] + weight[v] &gt; w[v]) &#123;</span><br><span class="line">                        w[v] &#x3D; w[u] + weight[v];</span><br><span class="line">                        pt[v] &#x3D; pt[u] + 1;</span><br><span class="line">                        pre[v] &#x3D; u;</span><br><span class="line">                    &#125;else if(w[u] + weight[v] &#x3D;&#x3D; w[v])&#123;</span><br><span class="line">                        double uAvg &#x3D; 1.0 * (w[u] + weight[v]) &#x2F; (pt[u] + 1);</span><br><span class="line">                        double vAvg &#x3D; 1.0 * w[v] &#x2F; pt[v];</span><br><span class="line">                        if (uAvg &gt; vAvg) &#123;</span><br><span class="line">                            pt[v] &#x3D; pt[u] + 1;</span><br><span class="line">                            pre[v] &#x3D; u;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void printPath(int v)&#123;</span><br><span class="line">    if (v &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        cout &lt;&lt; indexToCity[v];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    printPath(pre[v]);</span><br><span class="line">    cout &lt;&lt;&quot;-&gt;&quot;&lt;&lt;indexToCity[v];</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    string start, str1, str2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; start;</span><br><span class="line">    cityToIndex[start] &#x3D; 0;</span><br><span class="line">    indexToCity[0] &#x3D; start;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n - 1; i++) &#123;</span><br><span class="line">        cin &gt;&gt; str1 &gt;&gt; weight[i];&#x2F;&#x2F;读入happy值，点权</span><br><span class="line">        cityToIndex[str1] &#x3D; i;</span><br><span class="line">        indexToCity[i] &#x3D; str1;</span><br><span class="line">    &#125;</span><br><span class="line">    fill(G[0], G[0] + MAXV * MAXV, INF);&#x2F;&#x2F;初始化图G</span><br><span class="line">    for (int i &#x3D; 0; i &lt; k; i++)&#123;</span><br><span class="line">        cin &gt;&gt; str1 &gt;&gt; str2;</span><br><span class="line">        int c1 &#x3D; cityToIndex[str1], c2 &#x3D; cityToIndex[str2];</span><br><span class="line">        cin &gt;&gt; G[c1][c2];</span><br><span class="line">        G[c2][c1] &#x3D; G[c1][c2];&#x2F;&#x2F;无向边</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(0);</span><br><span class="line">    int rom &#x3D; cityToIndex[&quot;ROM&quot;];</span><br><span class="line">    printf(&quot;%d %d %d %d\n&quot;, num[rom], d[rom], w[rom], w[rom]&#x2F;pt[rom]);</span><br><span class="line">    printPath(rom);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>dijstra + dfs:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &quot;set&quot;</span><br><span class="line">#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXV &#x3D; 410;&#x2F;&#x2F;最大顶点数</span><br><span class="line">const int INF &#x3D; 1000000000;&#x2F;&#x2F;无穷大</span><br><span class="line">&#x2F;&#x2F;n 城市数目, k 边数, G 邻接矩阵, w 点权</span><br><span class="line">&#x2F;&#x2F;d[]最短距离,numPath记录最短路径条数</span><br><span class="line">&#x2F;&#x2F;maxW记录最大点权之和，maxAvg为最大平均点权</span><br><span class="line">int n, k, G[MAXV][MAXV], weight[MAXV];</span><br><span class="line">int d[MAXV], numPath &#x3D; 0, maxW &#x3D; 0;</span><br><span class="line">double maxAvg &#x3D; 0;</span><br><span class="line">bool vis[MAXV] &#x3D; &#123;false&#125;;</span><br><span class="line">vector&lt;int&gt; pre[MAXV];</span><br><span class="line">vector&lt;int&gt; tempPath, path;</span><br><span class="line">map&lt;string, int&gt; cityToIndex;</span><br><span class="line">map&lt;int, string&gt; indexToCity;</span><br><span class="line"></span><br><span class="line">void Dijstra(int s)&#123;&#x2F;&#x2F;起点s</span><br><span class="line">    fill(d, d + MAXV, INF);</span><br><span class="line">    d[s] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        int u &#x3D; -1, MIN &#x3D; INF;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (vis[j] &#x3D;&#x3D; false &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u &#x3D; j;</span><br><span class="line">                MIN &#x3D; d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (u &#x3D;&#x3D; -1) return;</span><br><span class="line">        vis[u] &#x3D; true;</span><br><span class="line">        for (int v &#x3D; 0; v &lt; n; v++) &#123;</span><br><span class="line">            if (vis[v] &#x3D;&#x3D; false &amp;&amp; G[u][v] !&#x3D; INF) &#123;</span><br><span class="line">                if (d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] &#x3D; d[u] + G[u][v];</span><br><span class="line">                    pre[v].clear();</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125; else if(d[u] + G[u][v] &#x3D;&#x3D; d[v])&#123;</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFS(int v)&#123;</span><br><span class="line">    if (v &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        tempPath.push_back(v);</span><br><span class="line">        numPath++;</span><br><span class="line">        int tempW &#x3D; 0;&#x2F;&#x2F;临时路径tempPath的点权之和</span><br><span class="line">        for (int i &#x3D; tempPath.size() - 2; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">            int id &#x3D; tempPath[i];</span><br><span class="line">            tempW +&#x3D; weight[id];</span><br><span class="line">        &#125;</span><br><span class="line">        double tempAvg &#x3D; 1.0 * tempW &#x2F; (tempPath.size() - 1);</span><br><span class="line">        if (tempW &gt; maxW) &#123;&#x2F;&#x2F;当前点权和更大</span><br><span class="line">            maxW &#x3D; tempW;</span><br><span class="line">            maxAvg &#x3D; tempAvg;</span><br><span class="line">            path &#x3D; tempPath;</span><br><span class="line">        &#125;else if (tempW &#x3D;&#x3D; maxAvg &amp;&amp; tempAvg &gt; maxAvg)&#123;</span><br><span class="line">            maxAvg &#x3D; tempAvg;</span><br><span class="line">            path &#x3D; tempPath;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.push_back(v);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; pre[v].size(); i++) &#123;</span><br><span class="line">        DFS(pre[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    string start, city1, city2;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k &gt;&gt; start;</span><br><span class="line">    cityToIndex[start] &#x3D; 0;</span><br><span class="line">    indexToCity[0] &#x3D; start;</span><br><span class="line">    for (int i &#x3D; 1; i &lt;&#x3D; n -1; i++) &#123;</span><br><span class="line">        cin &gt;&gt; city1 &gt;&gt; weight[i];</span><br><span class="line">        cityToIndex[city1] &#x3D; i;</span><br><span class="line">        indexToCity[i] &#x3D; city1;</span><br><span class="line">    &#125;</span><br><span class="line">    fill(G[0], G[0] + MAXV * MAXV, INF);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">        cin &gt;&gt; city1 &gt;&gt; city2;</span><br><span class="line">        int c1 &#x3D; cityToIndex[city1], c2 &#x3D; cityToIndex[city2];</span><br><span class="line">        cin &gt;&gt; G[c1][c2];</span><br><span class="line">        G[c2][c1] &#x3D; G[c1][c2];</span><br><span class="line">    &#125;</span><br><span class="line">    Dijstra(0);</span><br><span class="line">    int rom &#x3D; cityToIndex[&quot;ROM&quot;];</span><br><span class="line">    DFS(rom);</span><br><span class="line">    printf(&quot;%d %d %d %d\n&quot;, numPath, d[rom], maxW, (int)maxAvg);</span><br><span class="line">    for (int i &#x3D; path.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        cout &lt;&lt; indexToCity[path[i]];</span><br><span class="line">        if (i &gt; 0) &#123;</span><br><span class="line">            cout &lt;&lt;&quot;-&gt;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/26/235/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/26/235/" class="post-title-link" itemprop="url">PAT A1072</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-02-26 15:17:00 / 修改时间：18:38:51" itemprop="dateCreated datePublished" datetime="2017-02-26T15:17:00+00:00">2017-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>A gas station has to be built at such a location that the minimum distance between the station and any of the residential housing is as far away as possible. However it must guarantee that all the houses are in its service range.</p>
<p>Now given the map of the city and several candidate locations for the gas station, you are supposed to give the best recommendation. If there are more than one solution, output the one with the smallest average distance to all the houses. If such a solution is still not unique, output the one with the smallest index number.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. For each case, the first line contains 4 positive integers: N (&lt;= 103), the total number of houses; M (&lt;= 10), the total number of the candidate locations for the gas stations; K (&lt;= 104), the number of roads connecting the houses and the gas stations; and DS, the maximum service range of the gas station. It is hence assumed that all the houses are numbered from 1 to N, and all the candidate locations are numbered from G1 to GM.</p>
<p>Then K lines follow, each describes a road in the format<br>P1 P2 Dist<br>where P1 and P2 are the two ends of a road which can be either house numbers or gas station numbers, and Dist is the integer length of the road.</p>
<p>Output Specification:</p>
<p>For each test case, print in the first line the index number of the best location. In the next line, print the minimum and the average distances between the solution and all the houses. The numbers in a line must be separated by a space and be accurate up to 1 decimal place. If the solution does not exist, simply output “No Solution”.</p>
<p>Sample Input 1:<br>4 3 11 5<br>1 2 2<br>1 4 2<br>1 G1 4<br>1 G2 3<br>2 3 2<br>2 G2 1<br>3 4 2<br>3 G3 2<br>4 G1 3<br>G2 G1 1<br>G3 G2 2<br>Sample Output 1:<br>G1<br>2.0 3.3<br>Sample Input 2:<br>2 1 2 10<br>1 G1 9<br>2 G1 20<br>Sample Output 2:<br>No Solution<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &quot;set&quot;</span><br><span class="line">#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXV &#x3D; 1020;&#x2F;&#x2F;最大顶点数</span><br><span class="line">const int INF &#x3D; 1000000000;&#x2F;&#x2F;无穷大</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;n为顶点数，m为加油站数，k为边数，DS为服务范围，G为邻接矩阵</span><br><span class="line">&#x2F;&#x2F;d[]记录最短距离</span><br><span class="line">int n, m, k, DS, G[MAXV][MAXV];</span><br><span class="line">int d[MAXV];</span><br><span class="line">bool vis[MAXV] &#x3D; &#123;false&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Dijkstra算法求所有顶点到起点s的最短距离</span><br><span class="line">void Dijkstra(int s)&#123;</span><br><span class="line">    memset(vis, false, sizeof(vis));</span><br><span class="line">    fill(d, d + MAXV, INF);</span><br><span class="line">    d[s] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n + m; i++) &#123;</span><br><span class="line">        int u &#x3D; -1, MIN &#x3D; INF;</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n + m; j++) &#123;</span><br><span class="line">            if (vis[j] &#x3D;&#x3D; false &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u &#x3D; j;</span><br><span class="line">                MIN &#x3D; d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (u &#x3D;&#x3D; -1) return;</span><br><span class="line">        vis[u] &#x3D; true;</span><br><span class="line">        for (int v &#x3D; 1; v &lt;&#x3D; n + m; v++) &#123;</span><br><span class="line">            if (vis[v] &#x3D;&#x3D; false &amp;&amp; G[u][v] !&#x3D; INF) &#123;</span><br><span class="line">                if (d[u] + G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] &#x3D; d[u] + G[u][v];&#x2F;&#x2F;覆盖d[v]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;将str[]转换为数字，若str是数字，则返回本身；否则返回去掉G之后的数加上n</span><br><span class="line">int getID(char str[])&#123;</span><br><span class="line">    int i &#x3D; 0, len &#x3D; strlen(str), ID &#x3D; 0;</span><br><span class="line">    while (i &lt; len) &#123;</span><br><span class="line">        if (str[i] !&#x3D; &#39;G&#39;) &#123;</span><br><span class="line">            ID &#x3D; ID * 10 + (str[i] - &#39;0&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (str[0] &#x3D;&#x3D; &#39;G&#39;) &#123;</span><br><span class="line">        return ID + n;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return ID;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;k, &amp;DS);</span><br><span class="line">    int u, v, w;</span><br><span class="line">    char city1[5], city2[5];</span><br><span class="line">    fill(G[0], G[0] + MAXV * MAXV, INF);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; k; i++) &#123;</span><br><span class="line">        scanf(&quot;%s %s %d&quot;, city1, city2, &amp;w);</span><br><span class="line">        u &#x3D; getID(city1);</span><br><span class="line">        v &#x3D; getID(city2);</span><br><span class="line">        G[u][v] &#x3D; G[v][u] &#x3D; w;&#x2F;&#x2F;边权</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;ansDis存放最大的最短距离</span><br><span class="line">    &#x2F;&#x2F;ansAvg存放最小平均距离，ansID存放最终加油站ID</span><br><span class="line">    double ansDis &#x3D; -1, ansAvg &#x3D; INF;</span><br><span class="line">    int ansID &#x3D; -1;</span><br><span class="line">    for (int i &#x3D; n + 1; i &lt;&#x3D; n + m; i++) &#123;&#x2F;&#x2F;枚举所有加油站</span><br><span class="line">        double minDis &#x3D; INF, avg &#x3D; 0;&#x2F;&#x2F;minDis为最大的最近距离，avg为平均距离</span><br><span class="line">        Dijkstra(i);&#x2F;&#x2F;求出d数组</span><br><span class="line">        for (int j &#x3D; 1; j &lt;&#x3D; n; j++) &#123;&#x2F;&#x2F;枚举所有民房，求出minDis与avg</span><br><span class="line">            if (d[j] &gt; DS) &#123;&#x2F;&#x2F;存在距离大于DS的居民房，跳出</span><br><span class="line">                minDis &#x3D; -1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (d[j] &lt; minDis) minDis &#x3D; d[j];</span><br><span class="line">            avg +&#x3D; 1.0 * d[j] &#x2F; n;&#x2F;&#x2F;获取平均距离</span><br><span class="line">        &#125;</span><br><span class="line">        if (minDis &#x3D;&#x3D; -1) continue;&#x2F;&#x2F;跳过这个加油站</span><br><span class="line">        if (minDis &gt; ansDis) &#123;&#x2F;&#x2F;最大距离</span><br><span class="line">            ansDis &#x3D; minDis;</span><br><span class="line">            ansID &#x3D; i;</span><br><span class="line">            ansAvg &#x3D; avg;</span><br><span class="line">        &#125;else if (minDis &#x3D;&#x3D; ansDis &amp;&amp; avg &lt; ansAvg)&#123;&#x2F;&#x2F;更新最小平均距离</span><br><span class="line">            ansID &#x3D; i;</span><br><span class="line">            ansAvg &#x3D; avg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (ansID &#x3D;&#x3D; -1) printf(&quot;No Solution\n&quot;);&#x2F;&#x2F;无解</span><br><span class="line">    else&#123;</span><br><span class="line">        printf(&quot;G%d\n&quot;, ansID - n);</span><br><span class="line">        printf(&quot;%.1f %.1f\n&quot;, ansDis, ansAvg);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN,en,default">
    <link itemprop="mainEntityOfPage" href="http://www.hemisu.com/2017/02/26/233/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="何米酥">
      <meta itemprop="description" content="Just do...">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="何米酥`s Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2017/02/26/233/" class="post-title-link" itemprop="url">PAT A1030</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-02-26 14:19:00 / 修改时间：14:37:43" itemprop="dateCreated datePublished" datetime="2017-02-26T14:19:00+00:00">2017-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/algorithm-PAT/" itemprop="url" rel="index"><span itemprop="name">algorithm - PAT</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>A traveler’s map gives the distances between cities along the highways, together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.</p>
<p>Input Specification:</p>
<p>Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (&lt;=500) is the number of cities (and hence the cities are numbered from 0 to N-1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format:</p>
<p>City1 City2 Distance Cost</p>
<p>where the numbers are all integers no more than 500, and are separated by a space.</p>
<p>Output Specification:</p>
<p>For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.</p>
<p>Sample Input<br>4 5 0 3<br>0 1 1 20<br>1 3 2 30<br>0 3 4 10<br>0 2 2 20<br>2 3 1 20<br>Sample Output<br>0 2 3 3 40<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &quot;set&quot;</span><br><span class="line">#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXV &#x3D; 510;&#x2F;&#x2F;最大顶点数</span><br><span class="line">const int INF &#x3D; 1000000000;&#x2F;&#x2F;无穷大</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;n为顶点数，m为边数，st和ed为起点和终点</span><br><span class="line">&#x2F;&#x2F;G为距离矩阵，cost为花费矩阵</span><br><span class="line">&#x2F;&#x2F;d[]记录最短距离，c[]记录最小花费</span><br><span class="line">int n, m, st, ed, G[MAXV][MAXV], cost[MAXV][MAXV];</span><br><span class="line">int d[MAXV], c[MAXV], pre[MAXV];</span><br><span class="line">bool vis[MAXV] &#x3D; &#123;false&#125;;&#x2F;&#x2F;vis[i]表示顶点i已访问，初值均为false</span><br><span class="line"></span><br><span class="line">void Dijkstra(int s)&#123;&#x2F;&#x2F;s为起点</span><br><span class="line">    fill(d, d + MAXV, INF);&#x2F;&#x2F;fill函数将整个d数组赋为INF</span><br><span class="line">    fill(c, c + MAXV, INF);&#x2F;&#x2F;fill函数将整个c数组赋为INF</span><br><span class="line">    d[s] &#x3D; 0;</span><br><span class="line">    c[s] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        int u &#x3D; -1, MIN &#x3D; INF;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (vis[j] &#x3D;&#x3D; false &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                MIN &#x3D; d[j];</span><br><span class="line">                u &#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (u &#x3D;&#x3D; -1) return;</span><br><span class="line">        vis[u] &#x3D; true;</span><br><span class="line">        for (int v &#x3D; 0; v &lt; n; v++) &#123;</span><br><span class="line">            if (vis[v] &#x3D;&#x3D; false &amp;&amp; G[u][v] !&#x3D; INF) &#123;</span><br><span class="line">                if (d[u] +  G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] &#x3D; d[u] + G[u][v];</span><br><span class="line">                    c[v] &#x3D; c[u] + cost[u][v];</span><br><span class="line">                    pre[v] &#x3D; u;</span><br><span class="line">                &#125;else if(d[u] + G[u][v] &#x3D;&#x3D; d[v] &amp;&amp; c[u] + cost[u][v] &lt; c[v])&#123;</span><br><span class="line">                    c[v] &#x3D; c[u] + cost[u][v];</span><br><span class="line">                    pre[v] &#x3D; u;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFS(int v)&#123;&#x2F;&#x2F;打印路径</span><br><span class="line">    if (v &#x3D;&#x3D; st) &#123;&#x2F;&#x2F;递归终点</span><br><span class="line">        printf(&quot;%d &quot;, v);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    DFS(pre[v]);</span><br><span class="line">    printf(&quot;%d &quot;, v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;st, &amp;ed);</span><br><span class="line">    int u, v;</span><br><span class="line">    fill(G[0], G[0] + MAXV * MAXV, INF);&#x2F;&#x2F;初始化图</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;G[u][v], &amp;cost[u][v]);</span><br><span class="line">        G[v][u] &#x3D; G[u][v];</span><br><span class="line">        cost[v][u] &#x3D; cost[u][v];</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(st);</span><br><span class="line">    DFS(ed);</span><br><span class="line">    printf(&quot;%d %d\n&quot;, d[ed], c[ed]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>dijkstra + dfs做法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;string.h&quot;</span><br><span class="line">#include &quot;iostream&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stdlib.h&quot;</span><br><span class="line">#include &quot;vector&quot;</span><br><span class="line">#include &quot;set&quot;</span><br><span class="line">#include &quot;map&quot;</span><br><span class="line">&#x2F;&#x2F;#include &quot;stack&quot;</span><br><span class="line">#include &quot;queue&quot;</span><br><span class="line">#include &quot;algorithm&quot;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int MAXV &#x3D; 510;&#x2F;&#x2F;最大顶点数</span><br><span class="line">const int INF &#x3D; 1000000000;&#x2F;&#x2F;无穷大</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;n为顶点数，m为边数，st和ed为起点和终点</span><br><span class="line">&#x2F;&#x2F;G为距离矩阵，cost为花费矩阵</span><br><span class="line">&#x2F;&#x2F;d[]记录最短距离，c[]记录最小花费</span><br><span class="line">int n, m, st, ed, G[MAXV][MAXV], cost[MAXV][MAXV];</span><br><span class="line">int d[MAXV], minCost &#x3D; INF;</span><br><span class="line">bool vis[MAXV] &#x3D; &#123;false&#125;;&#x2F;&#x2F;vis[i]表示顶点i已访问，初值均为false</span><br><span class="line">vector&lt;int&gt; pre[MAXV];&#x2F;&#x2F;前驱</span><br><span class="line">vector&lt;int&gt; tempPath, Path;&#x2F;&#x2F;临时路径，最优路径</span><br><span class="line"></span><br><span class="line">void Dijkstra(int s)&#123;&#x2F;&#x2F;s为起点</span><br><span class="line">    fill(d, d + MAXV, INF);&#x2F;&#x2F;fill函数将整个d数组赋为INF</span><br><span class="line">    d[s] &#x3D; 0;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">        int u &#x3D; -1, MIN &#x3D; INF;</span><br><span class="line">        for (int j &#x3D; 0; j &lt; n; j++) &#123;</span><br><span class="line">            if (vis[j] &#x3D;&#x3D; false &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                MIN &#x3D; d[j];</span><br><span class="line">                u &#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (u &#x3D;&#x3D; -1) return;</span><br><span class="line">        vis[u] &#x3D; true;</span><br><span class="line">        for (int v &#x3D; 0; v &lt; n; v++) &#123;</span><br><span class="line">            if (vis[v] &#x3D;&#x3D; false &amp;&amp; G[u][v] !&#x3D; INF) &#123;</span><br><span class="line">                if (d[u] +  G[u][v] &lt; d[v]) &#123;</span><br><span class="line">                    d[v] &#x3D; d[u] + G[u][v];</span><br><span class="line">                    pre[v].clear();</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;else if(d[u] + G[u][v] &#x3D;&#x3D; d[v])&#123;</span><br><span class="line">                    pre[v].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void DFS(int v)&#123;&#x2F;&#x2F;打印路径</span><br><span class="line">    if (v &#x3D;&#x3D; st) &#123;&#x2F;&#x2F;递归边界</span><br><span class="line">        tempPath.push_back(v);&#x2F;&#x2F;加入st</span><br><span class="line">        int tempCost &#x3D; 0;&#x2F;&#x2F;记录当前路径花费之和(边权和)</span><br><span class="line">        for (int i &#x3D; tempPath.size() - 1; i &gt; 0; i--) &#123;</span><br><span class="line">            &#x2F;&#x2F;id当前, idNext下一个id</span><br><span class="line">            int id &#x3D; tempPath[i], idNext &#x3D; tempPath[i - 1];</span><br><span class="line">            tempCost +&#x3D; cost[id][idNext];</span><br><span class="line">        &#125;</span><br><span class="line">        if (tempCost &lt; minCost) &#123;</span><br><span class="line">            minCost &#x3D; tempCost;</span><br><span class="line">            Path &#x3D; tempPath;</span><br><span class="line">        &#125;</span><br><span class="line">        tempPath.pop_back();&#x2F;&#x2F;弹出st</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.push_back(v);</span><br><span class="line">    for (int i &#x3D; 0; i &lt; pre[v].size(); i++) &#123;</span><br><span class="line">        DFS(pre[v][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    tempPath.pop_back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;m, &amp;st, &amp;ed);</span><br><span class="line">    int u, v;</span><br><span class="line">    fill(G[0], G[0] + MAXV * MAXV, INF);&#x2F;&#x2F;初始化图</span><br><span class="line">    for (int i &#x3D; 0; i &lt; m; i++) &#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;G[u][v], &amp;cost[u][v]);</span><br><span class="line">        G[v][u] &#x3D; G[u][v];</span><br><span class="line">        cost[v][u] &#x3D; cost[u][v];</span><br><span class="line">    &#125;</span><br><span class="line">    Dijkstra(st);</span><br><span class="line">    DFS(ed);</span><br><span class="line">    for (int i &#x3D; Path.size() - 1; i &gt;&#x3D; 0; i--) &#123;</span><br><span class="line">        printf(&quot;%d &quot;, Path[i]);&#x2F;&#x2F;打印路径</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d %d\n&quot;, d[ed], minCost);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">何米酥</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@next-theme/pjax@0.4.0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '.page-configurations',
    '.main-inner',
    '.post-toc-wrap',
    '.languages',
    '.pjax'
  ],
  analytics: false,
  cacheBust: false,
  scrollRestoration: false,
  scrollTo: !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  const hasTOC = document.querySelector('.post-toc');
  document.querySelector('.sidebar-inner').classList.toggle('sidebar-nav-active', hasTOC);
  document.querySelector(hasTOC ? '.sidebar-nav-toc' : '.sidebar-nav-overview').click();
  NexT.utils.updateSidebarPosition();
});
</script>


  


















  








    <div class="pjax">
  

  

    </div>
</body>
</html>
