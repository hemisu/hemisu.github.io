{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/272/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"be82f293-ed90-59b0-8620-8306b8d1ef3c","excerpt":"Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder…","html":"<p>Suppose that all the keys in a binary tree are distinct positive integers. A unique binary tree can be determined by a given pair of postorder and inorder traversal sequences. And it is a simple standard routine to print the numbers in level-order. However, if you think the problem is too simple, then you are too naive. This time you are supposed to print the numbers in “zigzagging order” — that is, starting from the root, print the numbers level-by-level, alternating between left to right and right to left. For example, for the following tree you must output: 1 11 5 8 17 12 20 15.</p>\n<p><img src=\"https://www.patest.cn/upload/nc_ol5xekjcdy4.jpg\" alt=\"请输入图片描述\">\n<strong>Input Specification:</strong></p>\n<p>Each input file contains one test case. For each case, the first line gives a positive integer N (&#x3C;= 30), the total number of nodes in the binary tree. The second line gives the inorder sequence and the third line gives the postorder sequence. All the numbers in a line are separated by a space.</p>\n<p><strong>Output Specification:</strong></p>\n<p>For each test case, print the zigzagging sequence of the tree in a line. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p>\n<p><strong>Sample Input:</strong>\n8\n12 11 20 17 1 15 8 5\n12 20 17 11 15 8 5 1\n<strong>Sample Output:</strong>\n1 11 5 8 17 12 20 15</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include &lt;stdio.h>\n    #include &lt;iostream>\n    #include &lt;algorithm>\n    #include &lt;string.h>\n    #include &lt;string>\n    #include &lt;queue>\n    #include &lt;set>\n    #include &lt;map>\n    using namespace std;\n    \n    const int maxn = 35;\n    int n, post[maxn], in[maxn];\n    \n    vector&lt;int> layerVec;\n    struct node{\n    \tint data, layer;\n    \tnode *left, *right;\n    \tnode(){left = right = NULL;}//初始化\n    };\n    node* create(int postL, int postR, int inL, int inR){\n    \tif(postL > postR) return NULL;\n    \tnode *root = new node;\n    \troot->data = post[postR];\n    \tint k;\n    \tfor(k = inL; k &lt;= inR; k++){\n    \t\tif(in[k] == post[postR]) break;\n    \t}\n    \tint numLeft = k - inL;\n    \troot->left = create(postL, postL + numLeft - 1, inL, k - 1);\n    \troot->right = create(postL + numLeft, postR - 1, k + 1, inR);\n    \treturn root;\n    }\n    int maxLev = 0, level[maxn] = {0};\n    void layerOrder(node *root){\n    \tqueue&lt;node*> q;\n    \tq.push(root);\n    \troot->layer = 1;//第一层\n    \twhile(!q.empty()){\n    \t\tnode *now = q.front();\n    \t\tq.pop();\n    \t\tlayerVec.push_back(now->data);\n    \t\tlevel[now->layer]++;\n    \t\tmaxLev = max(maxLev, now->layer);\n    \t\tif(now->left != NULL){\n    \t\t\tq.push(now->left);\n    \t\t\tnow->left->layer = now->layer + 1;\n    \t\t}\n    \t\tif(now->right != NULL){\n    \t\t\tq.push(now->right);\n    \t\t\tnow->right->layer = now->layer + 1;\n    \t\t}\n    \t}\n    }\n    int main(){\n    \t\n    \t//freopen(\"in.txt\", \"r\", stdin);\n    \tscanf(\"%d\", &amp;n);\n    \tfor(int i = 0;i &lt; n; i++){\n    \t\tscanf(\"%d\", &amp;in[i]);\n    \t}\n    \tfor(int i = 0;i &lt; n; i++){\n    \t\tscanf(\"%d\", &amp;post[i]);\n    \t}\n    \tnode* root = create(0, n - 1, 0, n - 1);\n    \tlayerOrder(root);\n    \tint cnt = 0;//统计当前打印的数目\n    \tfor(int i = 1;i &lt;= maxLev; i++){\n    \t\tif(i % 2 == 1){//奇数行翻转\n    \t\t\treverse(layerVec.begin() + cnt, layerVec.begin() + cnt + level[i]);\n    \t\t}\n    \t\tcnt+= level[i];\n    \t}\n    \tfor(int i = 0;i &lt; n; i++){\n    \t\tprintf(\"%d\", layerVec[i]);\n    \t\tif(i &lt; n - 1) printf(\" \");\n    \t\telse printf(\"\\n\");\n    \t}\n    \treturn 0;\n    \n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1127 . ZigZagging on a Tree (30)","date":"March 05, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/270/"},"frontmatter":{"title":"PAT A1126 . Eulerian Path (25)"}},"next":{"fields":{"slug":"/old-posts/273/"},"frontmatter":{"title":"PAT A1121 . Damn Single (25)"}}},"pageContext":{"id":"be82f293-ed90-59b0-8620-8306b8d1ef3c","previousPostId":"0dc281fb-52fc-5ee4-bc2c-e10aa7d72313","nextPostId":"4d756940-074a-5f3a-b401-8d38d277c6f6"}},
    "staticQueryHashes": ["2841359383","3257411868"]}