{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/201/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"2638c14c-d271-548e-aee1-b9d804202df1","excerpt":"Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the…","html":"<p>Suppose that all the keys in a binary tree are distinct positive integers. Given the postorder and inorder traversal sequences, you are supposed to output the level order traversal sequence of the corresponding binary tree.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line gives a positive integer N (&#x3C;=30), the total number of nodes in the binary tree. The second line gives the postorder sequence and the third line gives the inorder sequence. All the numbers in a line are separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each test case, print in one line the level order traversal sequence of the corresponding binary tree. All the numbers in a line must be separated by exactly one space, and there must be no extra space at the end of the line.</p>\n<p>Sample Input:\n7\n2 3 1 5 7 6 4\n1 2 3 4 5 6 7\nSample Output:\n4 1 6 3 5 7 2</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    //#include \"stack\"\n    #include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int maxn = 50;\n    struct node{\n        int data;\n        node* lchild;\n        node* rchild;\n    };\n    int pre[maxn], in[maxn], post[maxn];//先序，中序以及后序\n    int n;//结点个数\n    //当前二叉树后序序列区间为[postL,postR], 中序序列区间为[inL, inR]\n    //create函数返回构建出的二叉树的根节点地址\n    node* create(int postL,int postR, int inL, int inR){\n        if (postL > postR) {\n            return NULL;//若后序序列长度小于0，则直接返回\n        }\n        node* root = new node;//新建一个结点，用来存放当前二叉树的根节点\n        root->data = post[postR];//新结点的数据域为根结点的值\n        int k;//k为根节点的值在中序序列中的位置\n        for (k = inL; k &lt;= inR; k++) {\n            if (in[k] == post[postR]) {//如果在中序序列中找到了\n                break;\n            }\n        }\n        int numLeft = k - inL;//左子树的结点个数\n        //返回左子树的根结点地址，赋值给root的左指针\n        root->lchild = create(postL, postL + numLeft - 1, inL, k - 1);\n        //返回右子树的根节点地址，赋值给root的右指针\n        root->rchild = create(postL + numLeft, postR - 1, k + 1, inR);\n        return root;\n    }\n    int num = 0;//已输出的结点个数\n    void BFS(node* root){\n        queue&lt;node*> q;//注意队列里面储存的是地址\n        q.push(root);//将根节点地址入队\n        while (!q.empty()) {\n            node* now = q.front();//取出队首元素\n            q.pop();\n            printf(\"%d\", now->data);//打印队首元素\n            num++;\n            if (num &lt; n) printf(\" \");\n            if (now->lchild != NULL) q.push(now->lchild);\n            if (now->rchild != NULL) q.push(now->rchild);\n        }\n    }\n    int main(){\n        scanf(\"%d\", &amp;n);\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%d\", &amp;post[i]);\n        }\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%d\", &amp;in[i]);\n        }\n        node* root = create(0, n - 1, 0, n - 1);//建树\n        BFS(root);\n        return 0;\n    }\n</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1020","date":"February 22, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/200/"},"frontmatter":{"title":"PAT A1091"}},"next":{"fields":{"slug":"/old-posts/202/"},"frontmatter":{"title":"PAT A1086"}}},"pageContext":{"id":"2638c14c-d271-548e-aee1-b9d804202df1","previousPostId":"3b912a9b-64d7-5214-95f1-6a8d21ed4c14","nextPostId":"b9273bab-1351-5a77-878f-87da5a7c5228"}},
    "staticQueryHashes": ["2841359383","3257411868"]}