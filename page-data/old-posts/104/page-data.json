{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/104/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"ae388a17-dbc4-5748-9ebf-b14a4dd87082","excerpt":"字符串APPAPT中包含了两个单词“PAT”，其中第一个PAT是第2位(P),第4位(A),第6位(T)；第二个PAT是第3位(P),第4位(A),第6位(T)。 现给定字符串，问一共可以形成多少个PAT？ 输入格式： 输入只有一行，包含一个字符串，长度不超过105，只包含P、A、T…","html":"<p>字符串APPAPT中包含了两个单词“PAT”，其中第一个PAT是第2位(P),第4位(A),第6位(T)；第二个PAT是第3位(P),第4位(A),第6位(T)。</p>\n<p>现给定字符串，问一共可以形成多少个PAT？</p>\n<p>输入格式：</p>\n<p>输入只有一行，包含一个字符串，长度不超过105，只包含P、A、T三种字母。</p>\n<p>输出格式：</p>\n<p>在一行中输出给定字符串中包含多少个PAT。由于结果可能比较大，只输出对1000000007取余数的结果。</p>\n<p>输入样例：\nAPPAPT\n输出样例：\n2</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    //#include \"algorithm\"\n    //using namespace std;\n    const int MAXN = 100010;\n    const int Mod = 1000000007;\n    char str[MAXN];\n    int leftNumP[MAXN] = {0};//写成了char型\n    int main(){\n        gets(str);\n        int len = (int)strlen(str);\n        for (int i = 0 ; i &lt; len; i++) {\n            if (i > 0) {\n                leftNumP[i] = leftNumP[i - 1];\n            }\n            if (str[i] == 'P') {\n                leftNumP[i]++;\n            }\n        }\n        int ans = 0,rightNumT = 0;\n        for (int i = len - 1; i >= 0; i--) {\n            if (str[i] == 'T') {\n                rightNumT++;\n            }else if (str[i] == 'A'){\n                ans = (ans + leftNumP[i] * rightNumT ) % Mod;\n            }\n        }\n        printf(\"%d\", ans);\n        \n        return 0;\n    }</code></pre></div>\n<p>算法笔记上的答案最后两个测试点通不过，原因不明\n20：13分改：抄代码不认真 把leftNumP定义成了char型。改回int就好了</p>\n<p>附上百度来的答案</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include &lt;stdio.h>  \n    #include &lt;string.h>  \n    int main() {  \n        char str[100001];  \n        gets(str);  \n        int numT = 0;  \n        int numAT = 0;  \n        int numPAT = 0;  \n        for(int i = strlen(str) - 1; i >= 0; --i) {               //从字符串后面向前遍历  \n            if(str[i] == 'T')                    //碰到T，记录该T后面T的总个数（包括这个T）  \n                ++numT;  \n            else if(str[i] == 'A')                   //碰到A，记录该A后面AT组合的总个数；其中包括之前统计的A后面AT的总个数加上这个A与后面全部T组合的个数（  \n                numAT = (numAT + numT) % 1000000007;  \n            else {                           //碰到P，记录该P后面PAT组合的总个数；同理  \n                numPAT = (numPAT + numAT) % 1000000007;  \n            }  \n        }  \n        printf(\"%d\", numPAT);  \n      \n      \n        return 0;  \n    }  </code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT B1040/A1093","date":"February 08, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/103/"},"frontmatter":{"title":"PAT A1082"}},"next":{"fields":{"slug":"/old-posts/105/"},"frontmatter":{"title":"PAT B1015/A1062"}}},"pageContext":{"id":"ae388a17-dbc4-5748-9ebf-b14a4dd87082","previousPostId":"d7d5f33f-28ad-599e-9fca-d73a9cb821eb","nextPostId":"301fe89d-a4dd-5ace-a409-7aff4cf5c8df"}},
    "staticQueryHashes": ["2841359383","3257411868"]}