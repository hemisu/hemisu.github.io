{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/133/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"7b000fb6-5dd5-58a7-b8fa-421e35dcab42","excerpt":"Given any permutation of the numbers {0, 1, 2,…, N-1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed…","html":"<p>Given any permutation of the numbers {0, 1, 2,…, N-1}, it is easy to sort them in increasing order. But what if Swap(0, *) is the ONLY operation that is allowed to use? For example, to sort {4, 0, 2, 1, 3} we may apply the swap operations in the following way:</p>\n<p>Swap(0, 1) => {4, 1, 2, 0, 3}\nSwap(0, 3) => {4, 1, 2, 3, 0}\nSwap(0, 4) => {0, 1, 2, 3, 4}</p>\n<p>Now you are asked to find the minimum number of swaps need to sort the given permutation of the first N nonnegative integers.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case, which gives a positive N (&#x3C;=105) followed by a permutation sequence of {0, 1, …, N-1}. All the numbers in a line are separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each case, simply print in a line the minimum number of swaps need to sort the given permutation.</p>\n<p>Sample Input:\n10 3 5 7 2 6 4 9 0 8 1\nSample Output:\n9</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    #include \"algorithm\"\n    using namespace std;\n    const int maxn = 100010;\n    int pos[maxn];\n    int main(){\n        int n, ans = 0;\n        scanf(\"%d\", &amp;n);\n        int left = n - 1, num;//left存放除0以外不在本位的数\n        for (int i = 0 ; i &lt; n; i++) {\n            scanf(\"%d\", &amp;num);\n            pos[num] = i;\n            if (num == i &amp;&amp; num !=0) {\n                left--;\n            }\n        }\n        int k = 1;//k存放除了0意外当前不在本位上的最小的数\n        while (left > 0) {\n            //如果0在本位上，则寻找一个当前不在本位上的数与0交换\n            if (pos[0] == 0) {\n                while (k &lt; n) {\n                    if (pos[k] != k) {\n                        swap(pos[0], pos[k]);\n                        ans++;\n                        break;\n                    }\n                    k++;\n                }\n            }\n            //只要0不在本位，就将0所在的位置的数的当前所处位置与0的位置交换\n            while (pos[0] != 0) {\n                swap(pos[0], pos[pos[0]]);\n                ans++;\n                left--;\n            }\n        }\n        printf(\"%d\\n\", ans);\n        \n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1067","date":"February 11, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/132/"},"frontmatter":{"title":"PAT A1037"}},"next":{"fields":{"slug":"/old-posts/134/"},"frontmatter":{"title":"PAT A1038"}}},"pageContext":{"id":"7b000fb6-5dd5-58a7-b8fa-421e35dcab42","previousPostId":"c17236d2-94aa-5b1d-afe4-2708043da35c","nextPostId":"3ec14147-2584-5809-995f-778c3a4a486f"}},
    "staticQueryHashes": ["2841359383","3257411868"]}