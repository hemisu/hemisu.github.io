{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/216/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"aac54947-12b1-511f-b49d-a0bcbcc39aec","excerpt":"An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they…","html":"<p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.\n<img src=\"https://www.patest.cn/upload/79_mtxjq1kj3gx.jpg\" alt=\"请输入图片描述\">\n<img src=\"https://www.patest.cn/upload/79_mtxjqnwja2o.jpg\" alt=\"请输入图片描述\"><br>\n<img src=\"https://www.patest.cn/upload/79_mtxjr4gyzdg.jpg\" alt=\"请输入图片描述\">\n<img src=\"https://www.patest.cn/upload/79_mtxjrh51o9y.jpg\" alt=\"请输入图片描述\">\nNow given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains a positive integer N (&#x3C;=20) which is the total number of keys to be inserted. Then N distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each test case, print ythe root of the resulting AVL tree in one line.</p>\n<p>Sample Input 1:\n5\n88 70 61 96 120\nSample Output 1:\n70\nSample Input 2:\n7\n88 70 61 96 120 90 65\nSample Output 2:\n88</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    #include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    //#include \"stack\"\n    #include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    struct node {\n        int v, height;//v为结点权值，height为当前子树高度\n        node *lchild,*rchild;\n    } *root, *null;\n    \n    //生成一个新结点，v为结点权值\n    node* newNode(int v){\n        node* Node = new node;\n        Node->v = v;\n        Node->height = 1;\n        Node->lchild = Node->rchild = NULL;\n        return Node;\n    }\n    //获取以root为根的子树当前的高度height\n    int getHeight(node* root){\n        if (root == NULL) {\n            return 0;\n        }\n        return root->height;\n    }\n    //更新结点root的height\n    void updateHeight(node* root){\n        //max+1\n        root->height = max(getHeight(root->lchild), getHeight(root->rchild)) + 1;\n    }\n    //计算结点root的平衡因子\n    int getBalance(node* root){\n        return getHeight(root->lchild) - getHeight(root->rchild);\n    }\n    //左旋\n    void L(node* &amp;root){\n        node* temp = root->rchild;\n        root->rchild = temp->lchild;\n        temp->lchild = root;\n        updateHeight(root);\n        updateHeight(temp);\n        root = temp;\n    }\n    //右旋\n    void R(node* &amp;root){\n        node* temp = root->lchild;\n        root->lchild = temp->rchild;\n        temp->rchild = root;\n        updateHeight(root);\n        updateHeight(temp);\n        root = temp;\n    }\n    //插入权值为v的结点\n    void insert(node* &amp;root, int v){\n        if (root == NULL) {\n            root = newNode(v);\n            return;\n        }\n        if (v &lt; root->v) {\n            insert(root->lchild, v);//往左子树插入\n            updateHeight(root);\n            if (getBalance(root) == 2) {\n                if (getBalance(root->lchild) == 1) {//LL\n                    R(root);\n                }else if(getBalance(root->lchild) == -1){//LR\n                    L(root->lchild);\n                    R(root);\n                }\n            }\n        }else{\n            insert(root->rchild, v);//往右子树插入\n            updateHeight(root);\n            if (getBalance(root) == -2) {\n                if (getBalance(root->rchild) == -1) {//RR\n                    L(root);\n                }else if(getBalance(root->rchild) == 1){//RL\n                    R(root->rchild);\n                    L(root);\n                }\n            }\n        }\n    }\n    int main(){\n        int n, v;\n        scanf(\"%d\", &amp;n);\n        for (int i = 0 ; i &lt; n; i++) {\n            scanf(\"%d\", &amp;v);\n            insert(root, v);\n        }\n        printf(\"%d\\n\", root->v);\n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1066","date":"February 23, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/215/"},"frontmatter":{"title":"PAT A1099"}},"next":{"fields":{"slug":"/old-posts/218/"},"frontmatter":{"title":"好朋友 - 并查集"}}},"pageContext":{"id":"aac54947-12b1-511f-b49d-a0bcbcc39aec","previousPostId":"eef3aea4-4d88-59f1-9abf-9c346dcbee8f","nextPostId":"37d161bf-785f-5878-823b-2619c1434c16"}},
    "staticQueryHashes": ["2841359383","3257411868"]}