{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/248/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"4808d6ed-2197-5897-a963-a816a129f8bc","excerpt":"在数码世界中有一个叫做“Radiation Zone”的区域，里面荒无人烟，仿佛遗迹一般。在这个区域中有N个城市（假设编号为从0到N-1），每个城市中都有一定数量的辐能。有M条已知长度的道路连接它们，每条道路都可以双向来往。 近期这个区域似有黑暗气息蛰伏，国王Shoutmon…","html":"<p>在数码世界中有一个叫做“Radiation Zone”的区域，里面荒无人烟，仿佛遗迹一般。在这个区域中有N个城市（假设编号为从0到N-1），每个城市中都有一定数量的辐能。有M条已知长度的道路连接它们，每条道路都可以双向来往。</p>\n<p>近期这个区域似有黑暗气息蛰伏，国王Shoutmon派出调查队前来调查这个区域中的城市。调查队的飞船降落在S号城市。由于飞船降落时气流不稳定，因此产生了辐能波，导致以S号城市为中心的L层以内（假设S号城市为最内层，记为第0层）的城市的辐能都会上升（只上升一次），上升的数值为 “城市的当前辐能乘以百分比p”的向上取整。其中百分比p在S号城市时为100%，且每向外扩散一层，百分比降低100%/L（例如，如果L为5，那么第0层（即S号城市）为100%，第1层为80%，第2层为60%，第3层为40%，第4层为20%，其中百分比均为浮点数）。所谓第X层是指，连接某城市与S号城市的最少数量的道路数，例如下图是一个例子，图中的数字为其层号。</p>\n<p><img src=\"http://shoutmon.qiniudn.com/pic.png\" alt=\"图片\"></p>\n<p>之后调查队需要前往T号城市调查。为了顺便清除城市中的辐能，他们准备了一个容量为K的辐能吸收器。辐能吸收器可以自动吸收城市中的辐能，且满容量时会自动将容器内的所有辐能都燃烧完毕，以继续吸收辐能。假设调查队总是把城市（含S号和T号城市）中的辐能吸收完毕。</p>\n<p>为了节省体力，调查队希望选择一条长度最短的路径前往T号城市；如果这样的路径有多条，那么从中选择到达T号城市时辐能吸收器内当前辐能最大的路径；如果这样的路径仍然有多条，那么从中选择路径后半段的城市的辐能之和最小的路径（所谓后半段是指，如果路径上有m个城市，那么后m/2个城市（含T号城市）是后半段的城市。例如，如果路径上有7个城市，那么路径的后3个城市（除法为向下取整）为后半段的城市）。数据保证这样的路径一定唯一。</p>\n<p>输入\n每个输入文件中一组数据。</p>\n<p>第一行六个整数N、M、L、K、S、T（2&#x3C;=N&#x3C;=500, M&#x3C;=N*(N-1)/2, 1&#x3C;=L&#x3C;=500, 2&#x3C;=K&#x3C;=100, S != T），分别代表城市个数、道路条数、辐能上升的层数、辐能吸收器的容量、起点城市编号、终点城市编号。</p>\n<p>接下来一行有N个正整数，分别给出N个城市的初始辐能（均为不超过100的正整数）。</p>\n<p>接下来M行，每行三个数字u、v、w，代表一条道路，其中u和v为道路的两个端点城市编号，w为道路的长度（w为不超过1000的正整数）。数据保证u不等于v，且相同的无序对(u,v)只出现一次。</p>\n<p>输出\n如果从S号城市不能到达T号城市，那么只输出-1。</p>\n<p>如果从S号城市能到达T号城市，那么输出两行：</p>\n<p>第一行输出四个整数， 即S号城市到T号城市的最短距离的路径条数（数据保证不超过100000条）、S号城市到T号城市的最短距离、通过最终选择的路径到达T号城市时辐能吸收器内的当前辐能、最终选择的路径的后半段城市的辐能之和。</p>\n<p>第二行输出最终选择的路径，路径上的城市之间用->隔开。</p>\n<p>样例输入\n7 8 1 7 0 6\n20 10 10 6 8 13 5\n0 1 1\n0 2 1\n1 3 1\n2 4 1\n2 5 1\n3 6 1\n4 6 1\n5 6 1\n样例输出\n3 3 5 11\n0->1->3->6</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">\n    #include &lt;cstdio>\n    #include &lt;cmath>\n    #include &lt;cstring>\n    #include &lt;vector>\n    #include &lt;queue>\n    #include &lt;algorithm>\n    using namespace std;\n    //N、M、L、K、S、T（2&lt;=N&lt;=500, M&lt;=N*(N-1)/2, 1&lt;=L&lt;=500, 2&lt;=K&lt;=100, S != T），分别代表城市个数、道路条数、辐能上升的层数、辐能吸收器的容量、起点城市编号、终点城市编号\n    const int maxn = 510;\n    const int INF = 1000000000;\n    int n, m, l, k, s, t;\n    int weight[maxn], G[maxn][maxn], d[maxn];\n    int numPath = 0, remainK = -1, halfSumK = INF;\n    bool inq[maxn] = {false}, vis[maxn] = {false};\n    vector&lt;int> tempPath, path;\n    vector&lt;int> pre[maxn];\n    struct node{\n        int layer;//层数\n        int id;\n    };\n    void init(){\n        fill(G[0], G[0]+ maxn * maxn, INF);\n        numPath = 0;\n        remainK = -1;\n        halfSumK = INF;\n        memset(vis, false, sizeof(vis));\n        memset(inq, false, sizeof(inq));\n        for (int i = 0; i &lt; maxn; i++) {\n            pre[i].clear();\n        }\n        tempPath.clear();\n        path.clear();\n    }\n    void DFS(int v){\n        if (v == s) {\n            tempPath.push_back(v);\n            numPath++;\n            int tempW = 0, temphalfSumK = 0;\n            for (int i = 0; i &lt; (int)tempPath.size() / 2; i++) {\n                int id = tempPath[i];\n                tempW += weight[id];\n                temphalfSumK += weight[id];\n            }\n            for (int i = (int)tempPath.size() / 2; i &lt; tempPath.size(); i++) {\n                int id = tempPath[i];\n                tempW += weight[id];\n            }\n            if (tempW % k > remainK) {\n                remainK = tempW % k;\n                halfSumK = temphalfSumK;\n                path = tempPath;\n            }else if(tempW % k == remainK ){\n                if (temphalfSumK &lt; halfSumK) {\n                    halfSumK = temphalfSumK;\n                    path = tempPath;\n                }\n            }\n            tempPath.pop_back();\n            return;\n        }\n        tempPath.push_back(v);\n        for (int i = 0; i &lt; pre[v].size(); i++) {\n            DFS(pre[v][i]);\n        }\n        tempPath.pop_back();\n    }\n    void Dijstra(int s){\n        fill(d, d + maxn, INF);\n        for (int i = 0; i &lt; n; i++) {\n            pre[i].push_back(i);//初始化路径\n        }\n        d[s] = 0;\n        for (int i = 0; i &lt; n; i++) {\n            int u = -1, MIN = INF;\n            for (int j = 0; j &lt; n; j++) {\n                if (vis[j] == false &amp;&amp; d[j] &lt; MIN) {\n                    u = j;\n                    MIN = d[j];\n                }\n            }\n            if (u == -1) return;\n            vis[u] = true;\n            for (int v = 0; v &lt; n; v++) {\n                if (vis[v] == false &amp;&amp; G[u][v] != INF) {\n                    if (d[u] + G[u][v] &lt; d[v] ) {\n                        d[v] = d[u] + G[u][v];\n                        pre[v].clear();\n                        pre[v].push_back(u);\n                    }else if(d[u] + G[u][v] == d[v]){\n                        pre[v].push_back(u);\n                    }\n                }\n            }\n        }\n    }\n    void BFS(int s){//BFS解决污染扩散问题\n        node start;\n        start.id = s;\n        start.layer = 0;\n        queue&lt;node> q;\n        q.push(start);\n        inq[start.id] = true;\n        while (!q.empty()) {\n            node now = q.front();\n            q.pop();\n            int u = now.id;\n            if (now.layer &lt; l) {\n                weight[u] += (int)(ceil(weight[u] * 1.0 * (l - now.layer) / l ) + 0.5);\n            }\n            for (int v = 0; v &lt; n; v++) {\n                if (inq[v] == false &amp;&amp; G[u][v] != INF) {\n                    node next;\n                    next.id = v;\n                    next.layer = now.layer + 1;\n                    q.push(next);\n                    inq[v] = true;\n                }\n            }\n            \n        }\n    }\n    \n    int main() {\n        init();\n        scanf(\"%d%d%d%d%d%d\", &amp;n, &amp;m, &amp;l, &amp;k, &amp;s, &amp;t);\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%d\", &amp;weight[i]);\n        }\n        int u, v, w;\n        for (int i = 0; i &lt; m; i++) {\n            scanf(\"%d%d%d\", &amp;u, &amp;v, &amp;w);\n            G[u][v] = G[v][u] = w;\n        }\n        BFS(s);\n        if(inq[t] == false){\n            printf(\"-1\\n\");\n            return 0;\n        }\n        Dijstra(s);\n        DFS(t);        //获取最优路径\n        printf(\"%d %d %d %d\\n\", numPath, d[t], remainK, halfSumK);\n        for(int i = path.size() - 1; i >= 0; i--) {\n            printf(\"%d\", path[i]);      //倒着输出路径上的结点\n            if(i > 0) printf(\"->\");\n            else printf(\"\\n\");\n        }\n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"2.28模拟题 problem4 调查黑暗气息","date":"March 01, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/247/"},"frontmatter":{"title":"2.28模拟题 problem1 判断三角形"}},"next":{"fields":{"slug":"/old-posts/251/"},"frontmatter":{"title":"3.1模拟题 problem3 某计算器的超电磁炮"}}},"pageContext":{"id":"4808d6ed-2197-5897-a963-a816a129f8bc","previousPostId":"69cd6618-bd18-501c-87ff-002d7764611b","nextPostId":"93722f25-24a0-59d9-abb0-2533f0f414b9"}},
    "staticQueryHashes": ["2841359383","3257411868"]}