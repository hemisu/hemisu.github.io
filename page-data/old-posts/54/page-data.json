{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/54/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"4a67cafb-bd4d-5d37-b4df-7b0a56228d9b","excerpt":"一个数组A中存有N（N>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M>=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M…","html":"<p>一个数组A中存有N（N>0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（M>=0）个位置，即将A中的数据由（A0 A1……AN-1）变换为（AN-M …… AN-1 A0 A1……AN-M-1）（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p>\n<p>输入格式：每个输入包含一个测试用例，第1行输入N ( 1&#x3C;=N&#x3C;=100)、M（M>=0）；第2行输入N个整数，之间用空格分隔。</p>\n<p>输出格式：在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p>\n<p>输入样例：\n6 2\n1 2 3 4 5 6\n输出样例：\n5 6 1 2 3 4</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;stdio.h>\nint main() {\n    int N,M,count = 0;\n    int arr[101];\n    scanf(\"%d%d\", &amp;N, &amp;M);\n    for (int i = 0; i &lt; N; i++) {\n        scanf(\"%d\", &amp;arr[i]);\n    }\n    M = M%N;//取余 修正\n    for (int i = N - M; i &lt; N; i++) {\n        printf(\"%d\", arr[i]);\n        count++;\n        if (count &lt; N) {\n            printf(\" \");\n        }\n    }\n    for (int i = 0; i &lt; N - M; i++) {\n        printf(\"%d\", arr[i]);\n        count++;\n        if (count &lt; N) {\n            printf(\" \");\n        }\n    }\n    return 0;\n}</code></pre></div>\n<p>另解：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;stdio.h>\nvoid reverse(int arr[],int p,int q){\n    for (; p &lt; q; p++, q--) {\n        int temp = arr[q];\n        arr[q] = arr[p];\n        arr[p] = temp;\n    }\n}\nint main() {\n    int N,M;\n    int arr[101];\n    scanf(\"%d%d\", &amp;N, &amp;M);\n    for (int i = 0; i &lt; N; i++) {\n        scanf(\"%d\", &amp;arr[i]);\n    }\n    M %= N;//取余 修正\n    reverse(arr, 0, N-M-1);\n    reverse(arr, N-M, N-1);\n    reverse(arr, 0, N-1);\n    for (int i = 0; i &lt; N; i++) {\n        printf(\"%d \",arr[i]);\n    }\n    return 0;\n}</code></pre></div>\n<p>算法笔记中利用最大公约数达到最小移动次数的方法：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include \"stdio.h\"\n//#include \"math.h\"\n#include \"string.h\"\n//#include \"iostream\"\n#include \"algorithm\"\nusing namespace std;\nint gcd(int a, int b){\n    if(b == 0) return a;\n    else return gcd(b, a % b);\n}\nint main(){\n    int a[110];\n    int n, m, temp, pos, next;\n    //temp为临时变量，pos存放当前处理的位置，next为下一个要处理的位置\n    scanf(\"%d%d\", &amp;n, &amp;m);\n    for (int i = 0; i &lt; n; i++) {\n        scanf(\"%d\", &amp;a[i]);\n    }\n    m = m % n;//修正m\n    if (m != 0) {\n        int d = gcd(m, n);\n        for (int i = n - m; i &lt; n - m + d; i++) {//枚举一个最大公约数的范围\n            temp = a[i];//把当前位置元素先拿走\n            pos = i;//记录当前要处理的位置\n            do{\n                //计算下一个要处理的位置\n                next = (pos - m + n) % n;\n                //如果下一个位置不是初始点\n                //则把下一个位置的元素赋值为当前处理位置\n                if (next != i) a[pos] = a[next];\n                else a[pos] = temp;//把一开始拿走的元素赋值给最后这个空位\n                pos = next;//传递位置\n            }while(pos != i);//循环位置直到当前处理位置回到初始位置结束\n        }\n    }\n    for (int i = 0 ; i &lt; n; i++) {\n        printf(\"%d\", a[i]);\n        if (i &lt; n -1) {\n            printf(\" \");\n        }\n    }\n    return 0;\n}</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT B1008","date":"January 17, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/53/"},"frontmatter":{"title":"PAT B1046"}},"next":{"fields":{"slug":"/old-posts/56/"},"frontmatter":{"title":"PAT B1012"}}},"pageContext":{"id":"4a67cafb-bd4d-5d37-b4df-7b0a56228d9b","previousPostId":"b23db04d-4b32-5c16-934b-00879545fc99","nextPostId":"d3e298ff-ac41-5cbb-a916-5c5c4f734e8b"}},
    "staticQueryHashes": ["2841359383","3257411868"]}