{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/205/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"3bb79e19-f508-5dde-b45e-d2d1ceb78aba","excerpt":"Given a non-empty tree with root R, and with weight Wi assigned to each tree node Ti. The weight of a path from R to L is defined to be the sum of the weights…","html":"<p>Given a non-empty tree with root R, and with weight Wi assigned to each tree node Ti. The weight of a path from R to L is defined to be the sum of the weights of all the nodes along the path from R to any leaf node L.</p>\n<p>Now given any weighted tree, you are supposed to find all the paths with their weights equal to a given number. For example, let’s consider the tree showed in Figure 1: for each node, the upper number is the node ID which is a two-digit number, and the lower number is the weight of that node. Suppose that the given number is 24, then there exists 4 different paths which have the same given weight: {10 5 2 7}, {10 4 10}, {10 3 3 6 2} and {10 3 3 6 2}, which correspond to the red edges in Figure 1.</p>\n<p><img src=\"https://www.patest.cn/upload/5b_mj58f84v11w.jpg\" alt=\"请输入图片描述\">\nFigure 1\n<strong>Input Specification:</strong></p>\n<p>Each input file contains one test case. Each case starts with a line containing 0 &#x3C; N &#x3C;= 100, the number of nodes in a tree, M (&#x3C; N), the number of non-leaf nodes, and 0 &#x3C; S &#x3C; 230, the given weight number. The next line contains N positive numbers where Wi (&#x3C;1000) corresponds to the tree node Ti. Then M lines follow, each in the format:</p>\n<p>ID K ID<a href=\"https://www.patest.cn/upload/5b_mj58f84v11w.jpg\">1</a> ID[2] … ID[K]\nwhere ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 00.</p>\n<p><strong>Output Specification:</strong></p>\n<p>For each test case, print all the paths with weight S in non-increasing order. Each path occupies a line with printed weights from the root to the leaf in order. All the numbers must be separated by a space with no extra space at the end of the line.</p>\n<p>Note: sequence {A1, A2, …, An} is said to be greater than sequence {B1, B2, …, Bm} if there exists 1 &#x3C;= k &#x3C; min{n, m} such that Ai = Bi for i=1, … k, and Ak+1 > Bk+1.</p>\n<p><strong>Sample Input:</strong>\n20 9 24\n10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2\n00 4 01 02 03 04\n02 1 05\n04 2 06 07\n03 3 11 12 13\n06 1 09\n07 2 08 10\n16 1 15\n13 3 14 16 17\n17 2 18 19\n<strong>Sample Output:</strong>\n10 5 2 7\n10 4 10\n10 3 3 6 2\n10 3 3 6 2</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    //#include \"stack\"\n    //#include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int maxn = 110;\n    struct node {\n        int weight;//数据域\n        vector&lt;int> child;//指针域\n    }Node[maxn];\n    bool cmp(int a, int b){\n        return Node[a].weight > Node[b].weight;\n    }\n    int n, m, S;//结点数、边数、给定的和\n    int path[maxn];//记录路径\n    //当前访问结点为index, nowNode为当前路径path上的结点个数\n    //sum为当前的结点weight和\n    void DFS(int index, int numNode, int sum){\n        if (sum > S) return;//当前和不等于S\n        if (sum == S) {//当前和等于S\n            if (Node[index].child.size()) return;//当前和等于S但不是叶子结点\n            for (int i = 0; i &lt; numNode; i++) {\n                printf(\"%d\", Node[path[i]].weight);\n                if (i &lt; numNode - 1) printf(\" \");\n                else printf(\"\\n\");\n            }\n            return;\n        }\n        for (int i = 0; i &lt; Node[index].child.size(); i++) {//枚举孩子结点\n            int child = Node[index].child[i];\n            path[numNode] = child;//将结点child添加到路径path末尾\n            DFS(child, numNode + 1, sum + Node[child].weight);//递归下一层\n        }\n    }\n    int main(){\n        scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;S);\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%d\", &amp;Node[i].weight);\n        }\n        int id, k, child;\n        for (int i = 0; i &lt; m; i++) {\n            scanf(\"%d%d\", &amp;id, &amp;k);\n            for (int j = 0; j &lt; k; j++) {\n                scanf(\"%d\", &amp;child);\n                Node[id].child.push_back(child);//child为结点id的孩子\n            }\n            sort(Node[id].child.begin(), Node[id].child.end(), cmp);\n        }\n        path[0] = 0;//路径设置第一个结点为0号结点\n        DFS(0, 1, Node[0].weight);//DFS求解\n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1053","date":"February 22, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/203/"},"frontmatter":{"title":"PAT A1102"}},"next":{"fields":{"slug":"/old-posts/206/"},"frontmatter":{"title":"PAT A1079"}}},"pageContext":{"id":"3bb79e19-f508-5dde-b45e-d2d1ceb78aba","previousPostId":"1b58d610-4b13-5aee-943e-db6829f6a97a","nextPostId":"8a0a7db9-1d9e-567e-a4d0-301e05474632"}},
    "staticQueryHashes": ["2841359383","3257411868"]}