{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/134/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"3ec14147-2584-5809-995f-778c3a4a486f","excerpt":"Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given {32, 321, 3214, 0229, 87}, we can recover…","html":"<p>Given a collection of number segments, you are supposed to recover the smallest number from them. For example, given {32, 321, 3214, 0229, 87}, we can recover many numbers such like 32-321-3214-0229-87 or 0229-32-87-321-3214 with respect to different orders of combinations of these segments, and the smallest number is 0229-321-3214-32-87.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case gives a positive integer N (&#x3C;=10000) followed by N number segments. Each segment contains a non-negative integer of no more than 8 digits. All the numbers in a line are separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each test case, print the smallest number in one line. Do not output leading zeros.</p>\n<p>Sample Input:\n5 32 321 3214 0229 87\nSample Output:\n22932132143287</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    #include \"algorithm\"\n    #include \"iostream\"\n    using namespace std;\n    const int maxn = 10010;\n    string str[maxn];\n    bool cmp(string a, string b){\n        return a + b &lt; b + a;//如果a+b &lt; b+a 就把a排在前面\n    }\n    int main(){\n        int n;\n        cin >> n;\n        for (int i = 0; i &lt; n; i++) {\n            cin >> str[i];\n        }\n        sort(str, str + n, cmp);\n        string ans;\n        for (int i = 0; i &lt; n; i++) {\n            ans += str[i];\n        }\n        while (ans.size() != 0 &amp;&amp; ans[0] == '0') {\n            ans.erase(ans.begin());//去除前导0\n        }\n        if (ans.size() == 0) {\n            cout &lt;&lt; 0;\n        }else{\n            cout &lt;&lt; ans;\n        }\n        return 0;\n    }</code></pre></div>\n<p>对于字符串S1 S2，如果S1+S2 &#x3C;S2+S1(+表示拼接)，那么把S1放在S2前面。\n其次string处理字符串真的强！\n如果串的大小不为0，要去除前面的所有0；\n附上需要用上的string函数（需要引用iostream 和 string）</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    (1) += 直接拼接\n    (2) == != &lt; &lt;= > >= 比较大小 字典序\n    (3) length()/size() 返回string的长度\n    (4) insert()\n        1. str.insert(pos,string) 在pos位置插入字符串string\n        2. str.insert(it,it2,it3) 在it的位置插入字符串的首尾it2,it3\n    (5) erase()\n        1. str.erase(it) 删除单个元素，it为元素迭代器\n        2. str.erase(first, last) 删除区间内的所有元素 first和last都为元素迭代器\n        3. str.erase(pos,length) pos为需要开始删除的起始位置\n    (6) clear() 清空string中的数据\n    (7) substr(pos,len) 返回从pos号开始的长度为len的子串\n    (8) string:npos 常数，本身值为-1 用以作为find函数失败匹配时的返回值。在unsigned_int类型中 -1 也为4294967295\n    (9) find()\n        1. str.find(str2) 返回str2在str中的位置，如果没找到，则返回string:npos\n        2. str.find(pos, str2) 返回从pos找起的str2在str中的位置，如果没找到，则返回string:npos\n    (10) replace()\n        1. str.replace(pos, len, str2) 把str2 从pos开始，长度为len换成str2\n        2. str.replace(it1, it2, str2) 把str的迭代器[it1,it2)范围的子串替换为str2</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1038","date":"February 11, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/133/"},"frontmatter":{"title":"PAT A1067"}},"next":{"fields":{"slug":"/old-posts/136/"},"frontmatter":{"title":"PAT B1030/A1085"}}},"pageContext":{"id":"3ec14147-2584-5809-995f-778c3a4a486f","previousPostId":"7b000fb6-5dd5-58a7-b8fa-421e35dcab42","nextPostId":"6954ba78-1668-56c5-8591-0eb28e7eb333"}},
    "staticQueryHashes": ["2841359383","3257411868"]}