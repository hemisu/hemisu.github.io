{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/197/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"82fca91f-8c2a-5832-b592-9a3842aa1c82","excerpt":"Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K…","html":"<p>Given a singly linked list L with integer keys, you are supposed to remove the nodes with duplicated absolute values of the keys. That is, for each value K, only the first node of which the value or absolute value of its key equals K will be kept. At the mean time, all the removed nodes must be kept in a separate list. For example, given L being 21→-15→-15→-7→15, you must output 21→-15→-7, and the removed list -15→15.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains the address of the first node, and a positive N (&#x3C;= 105) which is the total number of nodes. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>\n<p>Then N lines follow, each describes a node in the format:</p>\n<p>Address Key Next</p>\n<p>where Address is the position of the node, Key is an integer of which absolute value is no more than 104, and Next is the position of the next node.</p>\n<p>Output Specification:</p>\n<p>For each case, output the resulting linked list first, then the removed list. Each node occupies a line, and is printed in the same format as in the input.</p>\n<p>Sample Input:\n00100 5\n99999 -7 87654\n23854 -15 00000\n87654 15 -1\n00000 -15 99999\n00100 21 23854\nSample Output:\n00100 21 23854\n23854 -15 99999\n99999 -7 -1\n00000 -15 87654\n87654 15 -1</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    #include \"stdlib.h\"\n    #include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    //#include \"stack\"\n    //#include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int maxn = 100005;\n    const int TABLE = 100010;\n    struct NODE{\n        int address, data, next;\n    }node[maxn];\n    bool isExist[TABLE] = {false};//绝对值是否已经出现\n    vector&lt;NODE> list1,list2;//没被删除和被删除\n    int main(){\n        fill(isExist, isExist + TABLE, false);//初始化isExist为未出现\n    //    memset(isExist, false, sizeof(isExist));\n        int n, begin, address;\n        scanf(\"%d%d\", &amp;begin, &amp;n);\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%d\",&amp;address);\n            scanf(\"%d%d\", &amp;node[address].data, &amp;node[address].next);\n            node[address].address = address;\n        }\n    \n        for (int p = begin; p != -1; p = node[p].next) {\n            if (isExist[abs(node[p].data)] == false) {//不存在\n                isExist[abs(node[p].data)] = true;\n                list1.push_back(node[p]);\n            }else{\n                list2.push_back(node[p]);\n            }\n        }\n        //输出未删除的\n        for (int i = 0; i &lt; list1.size(); i++) {\n            if (i &lt; list1.size() - 1) {\n                printf(\"%05d %d %05d\\n\", list1[i].address, list1[i].data, list1[i+1].address);\n            }else{\n                printf(\"%05d %d -1\\n\", list1[i].address, list1[i].data);\n            }\n        }\n        //输出被删除的\n        for (int i = 0; i &lt; list2.size(); i++) {\n            if (i &lt; list2.size() - 1) {\n                printf(\"%05d %d %05d\\n\", list2[i].address, list2[i].data, list2[i+1].address);\n            }else{\n                printf(\"%05d %d -1\\n\", list2[i].address, list2[i].data);\n            }\n        }\n        return 0;\n    }</code></pre></div>\n<p>书上答案，思路巧妙，用每个结点加一个order，用maxn，2*maxn将静态链表分为 未删除的结点，删除的结点，无效结点</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    #include \"stdlib.h\"\n    #include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    //#include \"stack\"\n    //#include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int maxn = 100005;\n    const int TABLE = 100010;\n    struct NODE{\n        int address, data, next;\n        int order;\n    }node[maxn];\n    bool isExist[TABLE] = {false};//绝对值是否已经出现\n    bool cmp(NODE a, NODE b){\n        return a.order &lt; b.order;\n    }\n    int main(){\n        fill(isExist, isExist + TABLE, false);//初始化isExist为未出现\n    //    memset(isExist, false, sizeof(isExist));\n        for (int i = 0; i &lt; maxn; i++) {\n            node[i].order = 2 * maxn;\n        }\n        int n, begin, address;\n        scanf(\"%d%d\", &amp;begin, &amp;n);\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%d\",&amp;address);\n            scanf(\"%d%d\", &amp;node[address].data, &amp;node[address].next);\n            node[address].address = address;\n        }\n        int countValid = 0, countRemoved = 0, p = begin;\n        while (p != -1){\n            if (isExist[abs(node[p].data)] == false) {//data绝对值不存在\n                isExist[abs(node[p].data)] = true;\n                node[p].order = countValid++;\n            }else{\n                node[p].order = maxn + countRemoved++;\n            }\n            p = node[p].next;\n        }\n    \n        sort(node, node+maxn, cmp);\n        int count = countValid + countRemoved;\n        for (int i = 0; i &lt; count; i++) {\n            if (i != countValid -1 &amp;&amp; i != count -1) {\n                printf(\"%05d %d %05d\\n\", node[i].address, node[i].data, node[i + 1].address);\n            }else{\n                printf(\"%05d %d -1\\n\", node[i].address, node[i].data);\n            }\n        }\n        return 0;\n    }\n</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1097","date":"February 21, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/196/"},"frontmatter":{"title":"PAT B1025/A1074"}},"next":{"fields":{"slug":"/old-posts/199/"},"frontmatter":{"title":"PAT A1103"}}},"pageContext":{"id":"82fca91f-8c2a-5832-b592-9a3842aa1c82","previousPostId":"01127af7-12b1-5db8-9b7e-98b91e21e5c4","nextPostId":"6a9cf91f-9e6f-5669-926a-425f683ed9c9"}},
    "staticQueryHashes": ["2841359383","3257411868"]}