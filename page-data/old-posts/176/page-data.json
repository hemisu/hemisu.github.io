{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/176/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"daa0dfdf-983f-51b2-9607-038170879f9f","excerpt":"Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which…","html":"<p>Notice that the number 123456789 is a 9-digit number consisting exactly the numbers from 1 to 9, with no duplication. Double it we will obtain 246913578, which happens to be another 9-digit number consisting exactly the numbers from 1 to 9, only in a different permutation. Check to see the result if we double it again!</p>\n<p>Now you are suppose to check if there are more numbers with this property. That is, double a given number with k digits, you are to tell if the resulting number consists of only a permutation of the digits in the original number.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. Each case contains one positive integer with no more than 20 digits.</p>\n<p>Output Specification:</p>\n<p>For each test case, first print in a line “Yes” if doubling the input number gives a number that consists of only a permutation of the digits in the original number, or “No” if not. Then in the next line, print the doubled number.</p>\n<p>Sample Input:\n1234567899\nSample Output:\nYes\n2469135798</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"algorithm\"\n    using namespace std;\n    //typedef long long LL;\n    const int maxn = 100010;\n    struct bign{\n        int d[1000],len;\n        bign(){\n            memset(d, 0, sizeof(d));\n            len = 0;\n        }\n    };\n    bign change(char str[]){\n        bign a;\n        a.len = (int)strlen(str);\n        for (int i = 0; i &lt; a.len ; i++) {\n            a.d[i] = str[a.len - 1 - i] - '0';\n        }\n        return a;\n    }\n    bign multi(bign a, int b){\n        int carry = 0;\n        bign c;\n        for (int i = 0 ; i &lt; a.len; i++) {\n            int temp = a.d[i] * b + carry;\n            c.d[c.len++] = temp % 10;//个位作为该位结果\n            carry = temp / 10;//高位部分作为新的进位\n        }\n        while (carry) {//和加法不一样，乘法的进度可能不止一位，因此用while\n            c.d[c.len++] = carry % 10;\n            carry /= 10;\n        }\n        return c;\n    }\n    bool Judge(bign a,bign b){\n        if (a.len != b.len) return false;//长度不同\n        int count[10] = {0};\n        for (int i = 0; i &lt; a.len; i++) {\n            count[a.d[i]]++;//对应位置+1\n            count[b.d[i]]--;//对应位置-1\n        }\n        for (int i = 0; i &lt; 10; i++) {\n            if (count[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    void print(bign a){\n        //输出bign\n        for (int i = a.len -1; i >= 0; i--) {\n            printf(\"%d\", a.d[i]);\n        }\n    }\n    bool hashTable[10] = {true};\n    int main(){\n        char stra[21];\n        scanf(\"%s\", stra);\n        bign a = change(stra);\n        bign mul = multi(a, 2);\n        if (Judge(a, mul)) {\n            printf(\"Yes\\n\");\n        }else {\n            printf(\"No\\n\");\n        }\n        print(mul);\n        \n        return 0;\n    }\n \n</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1023","date":"February 18, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/174/"},"frontmatter":{"title":"PAT B1017"}},"next":{"fields":{"slug":"/old-posts/177/"},"frontmatter":{"title":"PAT A1024"}}},"pageContext":{"id":"daa0dfdf-983f-51b2-9607-038170879f9f","previousPostId":"8765ead0-69bd-5931-9d5c-f2c80e3486d8","nextPostId":"11c8b926-7641-5fb4-b691-af97cd35f463"}},
    "staticQueryHashes": ["2841359383","3257411868"]}