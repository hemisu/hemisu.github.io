{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/136/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"6954ba78-1668-56c5-8591-0eb28e7eb333","excerpt":"给定一个正整数数列，和正整数p，设这个数列中的最大值是M，最小值是m，如果M <= m * p，则称这个数列是完美数列。 现在给定参数p和一些正整数，请你从中选择尽可能多的数构成一个完美数列。 输入格式： 输入第一行给出两个正整数N和p，其中N（<= 105）是输入的正整数的个数，p（<= 10…","html":"<p>给定一个正整数数列，和正整数p，设这个数列中的最大值是M，最小值是m，如果M &#x3C;= m * p，则称这个数列是完美数列。</p>\n<p>现在给定参数p和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p>\n<p>输入格式：</p>\n<p>输入第一行给出两个正整数N和p，其中N（&#x3C;= 10<sup>5</sup>）是输入的正整数的个数，p（&#x3C;= 10<sup>9</sup>）是给定的参数。第二行给出N个正整数，每个数不超过10<sup>9</sup>。</p>\n<p>输出格式：</p>\n<p>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p>\n<p>输入样例：\n10 8\n2 3 20 4 5 1 6 7 8 9\n输出样例：\n8</p>\n<p>Given a sequence of positive integers and another positive integer p. The sequence is said to be a “perfect sequence” if M &#x3C;= m * p where M and m are the maximum and minimum numbers in the sequence, respectively.</p>\n<p>Now given a sequence and a parameter p, you are supposed to find from the sequence as many numbers as possible to form a perfect subsequence.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains two positive integers N and p, where N (&#x3C;= 105) is the number of integers in the sequence, and p (&#x3C;= 109) is the parameter. In the second line there are N positive integers, each is no greater than 109.</p>\n<p>Output Specification:</p>\n<p>For each test case, print in one line the maximum number of integers that can be chosen to form a perfect subsequence.</p>\n<p>Sample Input:\n10 8\n2 3 20 4 5 1 6 7 8 9\nSample Output:\n8</p>\n<p>二分法</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    #include \"algorithm\"\n    #include \"iostream\"\n    using namespace std;\n    const int maxn = 100010;\n    int n, p, a[maxn];\n    int main(){\n        scanf(\"%d%d\", &amp;n, &amp;p);\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%d\", &amp;a[i]);\n        }\n        sort(a, a + n);\n        int ans = 1;\n        for (int i = 0; i &lt; n ; i++) {\n            //在a[i+1]~a[n-1]中查找第一个超过a[i]*p，返回其位置给j\n            int j = upper_bound(a + i + 1, a + n, (long long)a[i] * p) - a;\n            ans = max(ans , j - i);\n        }\n        printf(\"%d\\n\", ans);\n        return 0;\n    }</code></pre></div>\n<p>two pointers法</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    //#include \"string.h\"\n    //#include \"iostream\"\n    #include \"algorithm\"\n    using namespace std;\n    const int maxn = 100010;\n    int main(){\n        int n, p, a[maxn];\n        scanf(\"%d%d\", &amp;n, &amp;p);\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%d\", &amp;a[i]);\n        }\n        sort(a, a + n);\n        int i = 0, j = 0, count = 1;\n        while (i &lt; n &amp;&amp; j &lt; n) {\n            while (j &lt;n &amp;&amp; a[j] &lt;= (long long) a[i] * p) {\n                count = max(count, j - i + 1);\n                j++;\n            }\n            i++;\n        }\n        printf(\"%d\\n\", count);\n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT B1030/A1085","date":"February 11, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/134/"},"frontmatter":{"title":"PAT A1038"}},"next":{"fields":{"slug":"/old-posts/140/"},"frontmatter":{"title":"PAT A1010"}}},"pageContext":{"id":"6954ba78-1668-56c5-8591-0eb28e7eb333","previousPostId":"3ec14147-2584-5809-995f-778c3a4a486f","nextPostId":"258fbd8f-ba8e-5ee3-a2ef-7bd0119ce323"}},
    "staticQueryHashes": ["2841359383","3257411868"]}