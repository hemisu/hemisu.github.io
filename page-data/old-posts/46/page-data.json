{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/46/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"a8c67ccf-8b4f-51db-a033-cc969cf31581","excerpt":"卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。 当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、…","html":"<p>卡拉兹(Callatz)猜想已经在1001中给出了描述。在这个题目里，情况稍微有些复杂。</p>\n<p>当我们验证卡拉兹猜想的时候，为了避免重复计算，可以记录下递推过程中遇到的每一个数。例如对n=3进行验证的时候，我们需要计算3、5、8、4、2、1，则当我们对n=5、8、4、2进行验证的时候，就可以直接判定卡拉兹猜想的真伪，而不需要重复计算，因为这4个数已经在验证3的时候遇到过了，我们称5、8、4、2是被3“覆盖”的数。我们称一个数列中的某个数n为“关键数”，如果n不能被数列中的其他数字所覆盖。</p>\n<p>现在给定一系列待验证的数字，我们只需要验证其中的几个关键数，就可以不必再重复验证余下的数字。你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</p>\n<p>输入格式：每个测试输入包含1个测试用例，第1行给出一个正整数K(&#x3C;100)，第2行给出K个互不相同的待验证的正整数n(1&#x3C;n&#x3C;=100)的值，数字间用空格隔开。</p>\n<p>输出格式：每个测试用例的输出占一行，按从大到小的顺序输出关键数字。数字间用1个空格隔开，但一行中最后一个数字后没有空格。</p>\n<p>输入样例：\n6\n3 5 6 7 8 11\n输出样例：\n7 6</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;stdio.h>\nint main() {\n    int num[101];\n    int i, k, n, len=0;\n    for(i = 0; i &lt; 101; i ++) {\n        num[i] = -1;\n    }\n    scanf(\"%d\", &amp;k);\n    for(i = 0; i &lt; k; i ++) {\n        scanf(\"%d\", &amp;n);\n        num[n] = 0;\n    }\n    for(i = 0; i &lt; 101; i ++) {\n        if(num[i] != 0) {\n            continue;\n        }\n        n = i;\n        while(n != 1) {\n            if(n % 2 == 0) {\n                n = n / 2;\n                if(n &lt;= 100) {\n                    num[n] = 1;\n                }\n            } else {\n                n = 3 * n + 1;\n                n = n / 2;\n                if(n &lt;= 100) {\n                    num[n] = 1;\n                }\n            }\n        }\n    }\n    for (i = 100; i; i--) {\n        if(num[i] == 0)len++;\n    }\n    for(i = 100; i ; i --) {\n        if(num[i] == 0) {\n            if (--len) {\n                printf(\"%d \",i);\n            }else{\n                printf(\"%d\",i);\n                break;\n            }\n        }\n    }\n}</code></pre></div>\n<p>2月10日更新：（学习散列后）</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include \"stdio.h\"\n//#include \"math.h\"\n#include \"string.h\"\n#include \"algorithm\"\nusing namespace std;\nbool cmp(int a, int b){\n    return a > b;\n}\nint main(){\n    int n, m, a[110];\n    scanf(\"%d\", &amp;n);\n    bool hashTable[10000] = {0};\n    for (int i = 0 ; i &lt; n; i++) {\n        scanf(\"%d\", &amp;a[i]);\n        m = a[i];\n        while (m != 1) {\n            if (m % 2 == 1) m = (3 * m +1) / 2;\n            else m = m/2;\n            hashTable[m] = true;\n        }\n    }\n    int cnt = 0;//计数『关键数』的个数\n    for (int i = 0; i &lt; n; i++) {\n        if (hashTable[a[i]] == false) {\n            cnt++;\n        }\n    }\n    sort(a,a+n,cmp);\n    for (int i = 0; i &lt; n; i++) {\n        if (hashTable[a[i]] == false) {\n            printf(\"%d\", a[i]);\n            cnt--;\n            if (cnt) {\n                printf(\" \");\n            }\n        }\n    }\n    return 0;\n}</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT B1005","date":"January 16, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/45/"},"frontmatter":{"title":"PAT B1004"}},"next":{"fields":{"slug":"/old-posts/47/"},"frontmatter":{"title":"PAT B1011"}}},"pageContext":{"id":"a8c67ccf-8b4f-51db-a033-cc969cf31581","previousPostId":"a256bdca-a5f1-5317-99b6-808cd1b3778c","nextPostId":"5ff935c2-c5df-51f3-8419-7ed3cd960c96"}},
    "staticQueryHashes": ["2841359383","3257411868"]}