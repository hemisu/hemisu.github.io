{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/244/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"53578c83-781e-5591-881b-0caf94b81d11","excerpt":"题目描述\n给定1~N的两个排列，使用这两个排列分别构建两棵二叉查找树（也就是通过往一棵空树中依次插入序列元素的构建方式）。如果这两棵二叉查找树完全相同，那么输出YES；否则输出NO。之后，输出第一个排列对应的二叉查找树的后序序列、层序序列。 输入\n每个输入文件中一组数据。 第一行1个正整数N（1<=N<=3…","html":"<p>题目描述\n给定1~N的两个排列，使用这两个排列分别构建两棵二叉查找树（也就是通过往一棵空树中依次插入序列元素的构建方式）。如果这两棵二叉查找树完全相同，那么输出YES；否则输出NO。之后，输出第一个排列对应的二叉查找树的后序序列、层序序列。</p>\n<p>输入\n每个输入文件中一组数据。</p>\n<p>第一行1个正整数N（1&#x3C;=N&#x3C;=30），表示二叉查找树中的结点个数。</p>\n<p>接下来两行，代表1~N的两个排列。</p>\n<p>输出\n如果两个排列代表的二叉查找树完全相同，那么输出一行YES，否则输出一行NO。</p>\n<p>接下来两行分别输出第一个排列对应的二叉查找树的后序序列、层序序列，整数之间用空格隔开。</p>\n<p>每行末尾不允许有多余的空格。</p>\n<p>样例输入\n5\n4 2 1 3 5\n4 5 2 3 1\n样例输出\nYES\n1 3 2 5 4\n4 2 5 1 3</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include &lt;iostream>\n    #include &lt;stdio.h>\n    #include &lt;algorithm>\n    #include &lt;string>\n    #include &lt;vector>\n    #include &lt;queue>\n    using namespace std;\n    const int maxn = 40;\n    struct node{\n        int data;\n        int lchild;\n        int rchild;\n    }Node[maxn * 2];\n    int nodenum = 0;\n    int n;\n    vector&lt;int> post1, post2, lev1;\n    int newNode(int x){\n        Node[nodenum].data = x;\n        Node[nodenum].lchild = -1;\n        Node[nodenum].rchild = -1;\n        return nodenum++;\n    }\n    void insert(int &amp;root, int x){\n        if (root == -1) {\n            root = newNode(x);\n            return;\n        }\n        if (x &lt; Node[root].data) {\n            insert(Node[root].lchild, x);\n        }\n        if (x > Node[root].data) {\n            insert(Node[root].rchild, x);\n        }\n    }\n    int createTree(int arr[]){\n        int root = -1;\n        for (int i = 0; i &lt; n; i++) {\n            insert(root, arr[i]);\n        }\n        return root;\n    }\n    void post(int root, vector&lt;int>&amp; vi){\n        if (root == -1) {\n            return;\n        }\n        post(Node[root].lchild, vi);\n        post(Node[root].rchild, vi);\n        vi.push_back(Node[root].data);\n    }\n    void lev(int root, vector&lt;int>&amp; vi){\n        queue&lt;int> q;\n        q.push(root);\n        while (!q.empty()) {\n            int now = q.front();\n            q.pop();\n            vi.push_back(Node[now].data);\n            if (Node[now].lchild != -1) q.push(Node[now].lchild);\n            if (Node[now].rchild != -1) q.push(Node[now].rchild);\n        }\n    }\n    int main() {\n        int str1[maxn], str2[maxn];\n        scanf(\"%d\", &amp;n);\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%d\", &amp;str1[i]);\n        }\n        int root1 = createTree(str1);\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%d\", &amp;str2[i]);\n        }\n        int root2 = createTree(str2);\n        post(root1, post1);\n        post(root2, post2);\n        lev(root1, lev1);\n        if (post1 == post2) {\n            printf(\"YES\\n\");\n        }else{\n            printf(\"NO\\n\");\n        }\n        for (int i = 0; i &lt; n; i++) {\n            printf(\"%d\", post1[i]);\n            if(i &lt; n - 1)printf(\" \");\n            else printf(\"\\n\");\n        }\n        for (int i = 0; i &lt; n; i++) {\n            printf(\"%d\", lev1[i]);\n            if(i &lt; n - 1)printf(\" \");\n            else printf(\"\\n\");\n        }\n        \n        return 0;\n    }\n</code></pre></div>","tableOfContents":"","frontmatter":{"title":"2.28模拟题 problem2 进击的二叉查找树","date":"March 01, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/243/"},"frontmatter":{"title":"PAT A1040 . Longest Symmetric String (25)"}},"next":{"fields":{"slug":"/old-posts/245/"},"frontmatter":{"title":"2.28模拟题 problem3 还原二叉树"}}},"pageContext":{"id":"53578c83-781e-5591-881b-0caf94b81d11","previousPostId":"89fdc922-8891-5e96-a013-cd3add9be20b","nextPostId":"e16be786-d88d-50a3-bbf8-efee344e4e54"}},
    "staticQueryHashes": ["2841359383","3257411868"]}