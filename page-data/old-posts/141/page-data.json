{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/141/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"6563c8fb-1aa1-5e8c-b8fa-b3705f2a65e9","excerpt":"Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M$). When making the…","html":"<p>Shopping in Mars is quite a different experience. The Mars people pay by chained diamonds. Each diamond has a value (in Mars dollars M$). When making the payment, the chain can be cut at any position for only once and some of the diamonds are taken off the chain one by one. Once a diamond is off the chain, it cannot be taken back. For example, if we have a chain of 8 diamonds with values M$3, 2, 1, 5, 4, 6, 8, 7, and we must pay M$15. We may have 3 options:</p>\n<ol>\n<li>Cut the chain between 4 and 6, and take off the diamonds from the position 1 to 5 (with values 3+2+1+5+4=15).</li>\n<li>Cut before 5 or after 6, and take off the diamonds from the position 4 to 6 (with values 5+4+6=15).</li>\n<li>Cut before 8, and take off the diamonds from the position 7 to 8 (with values 8+7=15).</li>\n</ol>\n<p>Now given the chain of diamond values and the amount that a customer has to pay, you are supposed to list all the paying options for the customer.</p>\n<p>If it is impossible to pay the exact amount, you must suggest solutions with minimum lost.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains 2 numbers: N (&#x3C;=105), the total number of diamonds on the chain, and M (&#x3C;=108), the amount that the customer has to pay. Then the next line contains N positive numbers D1 … DN (Di&#x3C;=103 for all i=1, …, N) which are the values of the diamonds. All the numbers in a line are separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each test case, print “i-j” in a line for each pair of i &#x3C;= j such that Di + … + Dj = M. Note that if there are more than one solution, all the solutions must be printed in increasing order of i.</p>\n<p>If there is no solution, output “i-j” for pairs of i &#x3C;= j such that Di + … + Dj > M with (Di + … + Dj - M) minimized. Again all the solutions must be printed in increasing order of i.</p>\n<p>It is guaranteed that the total value of diamonds is sufficient to pay the given amount.</p>\n<p>Sample Input 1:\n16 15\n3 2 1 5 4 6 8 7 16 10 15 11 9 12 14 13\nSample Output 1:\n1-5\n4-6\n7-8\n11-11\nSample Input 2:\n5 13\n2 4 5 7 9\nSample Output 2:\n2-4\n4-5</p>\n<p>求等于S的子串：\n思路，先令Sum表示1-i的值，这样做的好处是如果想知道3-5的和只要计算Sum[5]-Sum[2]就可以了</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include \"stdio.h\"\n//#include \"math.h\"\n//#include \"string.h\"\n//#include \"algorithm\"\n//#include \"iostream\"\n//using namespace std;\nconst int maxn = 100010;\nint sum[maxn];\nint n, S, nearS = 100000010;\n//upper_bound 函数返回在[L,R]内第一个大于x的位置\nint upper_bound(int L, int R, int x){\n    int left = L, right = R, mid;\n    while (left &lt; right) {\n        mid = (left + right) / 2;\n        if (sum[mid] > x) {\n            right = mid;\n        }else{\n            left = mid + 1;\n        }\n    }\n    return left;\n}\nint main(){\n    scanf(\"%d%d\", &amp;n, &amp;S);\n    sum[0] = 0;\n    for (int i = 1; i &lt;= n ; i++) {\n        scanf(\"%d\", &amp;sum[i]);\n        sum[i] += sum[i - 1];\n    }\n    for (int i = 1; i &lt;= n; i++) {//遍历左端点\n        int j = upper_bound(i, n + 1, sum[i - 1] + S);//找右端点\n        if (sum[j - 1] - sum[i - 1] == S) {\n            nearS = S;//查找成功，最接近S的就是S\n            break;\n        }else if(j &lt;= n &amp;&amp; sum[j] - sum[i - 1] &lt; nearS){\n            nearS = sum[j] - sum[i - 1];//存在大于S的解并小鱼nearS\n        }\n    }\n    for (int i = 1; i &lt;= n; i++){\n        int j = upper_bound(i, n + 1, sum[i - 1] + S);//找右端点\n        if(S == nearS){\n            if (sum[j - 1] - sum[i - 1] == nearS) {\n                printf(\"%d-%d\\n\", i, j - 1);\n            }\n        }else{\n            if (sum[j] - sum[i - 1] == nearS) {\n                printf(\"%d-%d\\n\", i, j);\n            }\n        }\n        \n    }\n    return 0;\n}</code></pre></div>\n<p>一会儿j-1一会儿j的原因是，upper_bound函数返回的是第一个大于x的位置\n当sum[i-1]+s == sum[j] 时 upper_bound返回的值是left + 1,此时需要-1；\n而找不到sum[i-1]+s == sum[j]时会返回一个最小的大于S的位置为left + 1，此时不需要-1。</p>","tableOfContents":"","frontmatter":{"title":"PAT A1044","date":"February 12, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/140/"},"frontmatter":{"title":"PAT A1010"}},"next":{"fields":{"slug":"/old-posts/147/"},"frontmatter":{"title":"PAT B1035/A1089"}}},"pageContext":{"id":"6563c8fb-1aa1-5e8c-b8fa-b3705f2a65e9","previousPostId":"258fbd8f-ba8e-5ee3-a2ef-7bd0119ce323","nextPostId":"f8e1a711-93cf-59a7-8327-6cf09194cf2b"}},
    "staticQueryHashes": ["2841359383","3257411868"]}