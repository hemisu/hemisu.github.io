{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/213/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"b279f812-5b46-500b-91c4-0f34a2506e25","excerpt":"A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties: The left subtree of a node contains only nodes with keys…","html":"<p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p>\n<p>The left subtree of a node contains only nodes with keys less than the node’s key.\nThe right subtree of a node contains only nodes with keys greater than or equal to the node’s key.\nBoth the left and right subtrees must also be binary search trees.\nA Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p>\n<p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains a positive integer N (&#x3C;=1000). Then N distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p>\n<p>Output Specification:</p>\n<p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p>\n<p>Sample Input:\n10\n1 2 3 4 5 6 7 8 9 0\nSample Output:\n6 3 8 1 5 7 9 0 2 4</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    #include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    //#include \"stack\"\n    #include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int maxn = 1010;\n    //n为结点数，number用以存放结点权值，CBT用以存放完全二叉树\n    //index从小到大枚举number数组\n    int n, number[maxn], CBT[maxn], indexs = 0;\n    void inOrder(int root){\n        if(root > n) return;//空结点 返回\n        inOrder(2*root);//左子树\n        CBT[root] = number[indexs++];\n        inOrder(2*root +1);//右子树\n    }\n    int main(){\n        scanf(\"%d\", &amp;n);\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%d\", &amp;number[i]);\n        }\n        sort(number, number + n);\n        inOrder(1);\n        for (int i = 1; i &lt;= n ; i++) {\n            printf(\"%d\", CBT[i]);\n            if(i &lt; n)   printf(\" \");\n        }\n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1064","date":"February 23, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/212/"},"frontmatter":{"title":"PAT A1043"}},"next":{"fields":{"slug":"/old-posts/215/"},"frontmatter":{"title":"PAT A1099"}}},"pageContext":{"id":"b279f812-5b46-500b-91c4-0f34a2506e25","previousPostId":"83cf2b5c-ae4d-5be0-9687-eab7e449c8b5","nextPostId":"eef3aea4-4d88-59f1-9abf-9c346dcbee8f"}},
    "staticQueryHashes": ["2841359383","3257411868"]}