{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/171/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"9fdf4107-fa5c-5061-b82f-d0393c7d111b","excerpt":"Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 356*7, where 5, 6, and 7 are the…","html":"<p>Among all the factors of a positive integer N, there may exist several consecutive numbers. For example, 630 can be factored as 3<em>5</em>6*7, where 5, 6, and 7 are the three consecutive numbers. Now given any positive N, you are supposed to find the maximum number of consecutive factors, and list the smallest sequence of the consecutive factors.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case, which gives the integer N (1&#x3C;N&#x3C;231).</p>\n<p>Output Specification:</p>\n<p>For each test case, print in the first line the maximum number of consecutive factors. Then in the second line, print the smallest sequence of the consecutive factors in the format “factor[1]<em>factor[2]</em>…*factor[k]”, where the factors are listed in increasing order, and 1 is NOT included.</p>\n<p>Sample Input:\n630\nSample Output:\n3\n5<em>6</em>7</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    #include \"math.h\"\n    //#include \"string.h\"\n    //#include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"algorithm\"\n    using namespace std;\n    typedef long long LL;\n    int main(){\n        LL n;\n        scanf(\"%lld\", &amp;n);\n        //sqrt为根号N，ansLen为最长连续整数，ansI为对应的第一个整数\n        LL sqr = (int)sqrt(1.0*n), ansI, ansLen = 0;\n        for (LL i = 2; i &lt;= sqr; i++) {\n            LL temp = 1, j = i;//temp为当前连续整数的乘积\n            while (1) {//让j从i开始不断加1，看最长能到多少\n                temp *= j;\n                if (n % temp != 0) {\n                    break;//不可以整除，跳出\n                }\n                if (j - i + 1 > ansLen) {//发现了更长的长度\n                    ansI = i;\n                    ansLen = j - i + 1;\n                }\n                j++;\n            }\n        }\n        if (ansLen == 0) {//最大长度为0，说明根号n范围内没有解\n            printf(\"1\\n%lld\", n);//输出n本身\n        }else{\n            printf(\"%lld\\n\", ansLen);//输出最大长度\n            for (LL i = 0; i &lt; ansLen ; i++) {\n                printf(\"%lld\", ansI + i);\n                if (i &lt; ansLen - 1) {\n                    printf(\"*\");\n                }\n            }\n        }\n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1096","date":"February 17, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/170/"},"frontmatter":{"title":"PAT A1078"}},"next":{"fields":{"slug":"/old-posts/173/"},"frontmatter":{"title":"PAT统计 做题数目 查询 头文件技巧"}}},"pageContext":{"id":"9fdf4107-fa5c-5061-b82f-d0393c7d111b","previousPostId":"b53164b1-8f27-5884-a1d5-b1e7ff249021","nextPostId":"06470d81-91eb-55ff-9380-ee579b105788"}},
    "staticQueryHashes": ["2841359383","3257411868"]}