{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/41/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"2cadfbce-7bfb-5f00-9f25-2e3c29bb56d2","excerpt":"我要通过！(20) “答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有P, A, T这三种字符，不可以包含其它字符； 任意形如 xPATx…","html":"<ol start=\"1003\">\n<li>我要通过！(20)</li>\n</ol>\n<p>“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于PAT的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。</p>\n<p>得到“答案正确”的条件是：</p>\n<ol>\n<li>字符串中必须仅有P, A, T这三种字符，不可以包含其它字符；</li>\n<li>任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串；</li>\n<li>如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a, b, c 均或者是空字符串，或者是仅由字母 A 组成的字符串。</li>\n</ol>\n<p>现在就请你为PAT写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。\n输入格式： 每个测试输入包含1个测试用例。第1行给出一个自然数n (&#x3C;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过100，且不包含空格。</p>\n<p>输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出YES，否则输出NO。</p>\n<p>输入样例：\n8\nPAT\nPAAT\nAAPATAA\nAAPAATAAAA\nxPATx\nPT\nWhatever\nAPAAATAA\n输出样例：\nYES\nYES\nYES\nYES\nNO\nNO\nNO\nNO</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include &lt;string.h>\n#include &lt;stdio.h>\nint main(){\n\tchar str[101];\n\tint j,n;\n\tint count_P,count_A,count_T,pos_P,pos_T;\n\tscanf(\"%d\\n\",&amp;n);\n\twhile( n > 0 ){\n\t\tgets(str);\n\t\tcount_P = count_A = count_T = pos_P = pos_T =0;\n\t\tfor(j = 0; j&lt;strlen(str);j++){\n\t\t\tif(str[j] == 'P'){\n\t\t\t\tcount_P++;\n\t\t\t\tpos_P = j;\n\t\t\t}\n\t\t\tif(str[j] == 'A')count_A++;\n\t\t\tif(str[j] == 'T'){\n\t\t\t\tcount_T++;\n\t\t\t\tpos_T = j;\n\t\t\t}\n\t\t}\n\t\tif(count_P+count_A+count_T != strlen(str) ||\n\t\t\tpos_T-pos_P&lt;=1 ||count_P>1 ||count_T>1||\n\t\t\tpos_P*(pos_T-pos_P-1) != strlen(str)-pos_T-1){\n\t\t\t\tprintf(\"NO\\n\");\n\t\t}else{\n\t\t\tprintf(\"YES\\n\");\n\t\t}\n\t\tn--;\n\t}\n\treturn 0;\n}</code></pre></div>\n<p>收获\n这题是真的不会了：D 受到打击几天没写，答案百度来的。可用。</p>\n<p>算法笔记上的：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">#include \"stdio.h\"\n//#include \"math.h\"\n#include \"string.h\"\n//#include \"iostream\"\n//#include \"algorithm\"\n//using namespace std;\nint main(){\n    int T;\n    scanf(\"%d\", &amp;T);\n    while (T--) {\n        char str[110];\n        scanf(\"%s\", str);\n        int len = (int)strlen(str);\n        //分别代表P,T,除PAT以外的字符个数\n        int num_p = 0, num_t = 0, other = 0;\n        int loc_p = -1, loc_t = -1;//分别代表p的位置，t的位置\n        for (int i = 0; i &lt; len ; i++) {\n            if (str[i] == 'P') {\n                num_p++;\n                loc_p = i;\n            }else if (str[i] == 'T'){\n                num_t++;\n                loc_t = i;\n            }else if (str[i] != 'A'){\n                other++;\n            }\n        }\n        //如果P的个数不为1，或者T的个数不为1\n        //或者存在PAT以外的字符，或者P和T之间没有字符\n        if ((num_p != 1) || (num_t != 1) || (other != 0) || (loc_t - loc_p &lt;= 1)) {\n            printf(\"NO\\n\");\n            continue;\n        }\n        //x,y,z\n        int x = loc_p, y = loc_t - loc_p - 1, z = len - loc_t -1;\n        if (z - x * (y - 1) == x) {\n            printf(\"YES\\n\");\n        }else{\n            printf(\"NO\\n\");\n        }\n    }\n    return 0;\n}</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT B1003","date":"January 04, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/40/"},"frontmatter":{"title":"PAT B1009"}},"next":{"fields":{"slug":"/old-posts/43/"},"frontmatter":{"title":"递归应用 全排列"}}},"pageContext":{"id":"2cadfbce-7bfb-5f00-9f25-2e3c29bb56d2","previousPostId":"bd7c0e2a-3f2a-5ba7-b005-3a6474f182de","nextPostId":"d3cdbe41-1245-56af-b425-be47923d78f7"}},
    "staticQueryHashes": ["2841359383","3257411868"]}