{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/196/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"01127af7-12b1-5db8-9b7e-98b91e21e5c4","excerpt":"Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K =…","html":"<p>Given a constant K and a singly linked list L, you are supposed to reverse the links of every K elements on L. For example, given L being 1→2→3→4→5→6, if K = 3, then you must output 3→2→1→6→5→4; if K = 4, you must output 4→3→2→1→5→6.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive N (&#x3C;= 105) which is the total number of nodes, and a positive K (&#x3C;=N) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p>\n<p>Then N lines follow, each describes a node in the format:</p>\n<p>Address Data Next</p>\n<p>where Address is the position of the node, Data is an integer, and Next is the position of the next node.</p>\n<p>Output Specification:</p>\n<p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p>\n<p>Sample Input:\n00100 6 4\n00000 4 99999\n00100 1 12309\n68237 6 -1\n33218 3 00000\n99999 5 68237\n12309 2 33218\nSample Output:\n00000 4 33218\n33218 3 12309\n12309 2 00100\n00100 1 99999\n99999 5 68237\n68237 6 -1</p>\n<p>给定一个常数K以及一个单链表L，请编写程序将L中每K个结点反转。例如：给定L为1→2→3→4→5→6，K为3，则输出应该为3→2→1→6→5→4；如果K为4，则输出应该为4→3→2→1→5→6，即最后不到K个元素不反转。</p>\n<p>输入格式：</p>\n<p>每个输入包含1个测试用例。每个测试用例第1行给出第1个结点的地址、结点总个数正整数N(&#x3C;= 105)、以及正整数K(&#x3C;=N)，即要求反转的子链结点的个数。结点的地址是5位非负整数，NULL地址用-1表示。</p>\n<p>接下来有N行，每行格式为：</p>\n<p>Address Data Next</p>\n<p>其中Address是结点地址，Data是该结点保存的整数数据，Next是下一结点的地址。</p>\n<p>输出格式：</p>\n<p>对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。</p>\n<p>输入样例：\n00100 6 4\n00000 4 99999\n00100 1 12309\n68237 6 -1\n33218 3 00000\n99999 5 68237\n12309 2 33218\n输出样例：\n00000 4 33218\n33218 3 12309\n12309 2 00100\n00100 1 99999\n99999 5 68237\n68237 6 -1</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    #include \"stdlib.h\"\n    //#include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    //#include \"stack\"\n    #include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int maxn = 100010;\n    struct Node{\n        int address, data, next;\n        int order;//结点在链表上的序号，无效结点记为maxn\n    }node[maxn];\n    bool cmp(Node a, Node b){\n        if (a.order == -1 || b.order == -1) {\n            return a.order > b.order;\n        }else{\n            return a.order &lt; b.order;\n        }//按order从小到大排序\n    }\n    int main(){\n        for (int i = 0; i &lt; maxn; i++) {\n            node[i].order = -1;//初始化全部为无效结点\n        }\n        int begin, n, K, address;\n        scanf(\"%d%d%d\", &amp;begin, &amp;n, &amp;K);//起始地址、结点个数、步长\n        for (int i = 0; i &lt; n ; i++) {\n            scanf(\"%d\", &amp;address);\n            scanf(\"%d%d\", &amp;node[address].data, &amp;node[address].next);\n            node[address].address = address;\n        }\n        int p = begin, count = 0;//count计数有效结点的数目\n        while (p != -1) {\n            node[p].order = count++;//结点在单链表中的序号\n            p = node[p].next;//下一个结点\n        }\n        sort(node, node + maxn, cmp);//按单链表从头到尾顺序排列\n        //有效结点为前count个结点，为了下面书写方便，因此把count赋值给n\n        n = count;\n        //单链表已经形成，下面是按题目要求的输出\n        for (int i = 0; i &lt; n / K; i++) {//枚举完整的n/K块\n            for (int j = (i + 1) * K - 1; j > i * K; j--) {//第i块倒着输出\n                printf(\"%05d %d %05d\\n\", node[j].address,node[j].data,node[j-1].address);\n            }\n            //下面是每一块最后一个结点的next地址的处理\n            printf(\"%05d %d \", node[i*K].address, node[i*K].data);\n            if (i &lt; n/K -1) {//如果不是最后一块，就指向下一块的最后一个结点\n                printf(\"%05d\\n\", node[(i + 2)*K -1].address);\n            }else{//是最后一块时\n                if (n%K == 0) {//恰好是最后一个结点，输出-1\n                    printf(\"-1\\n\");\n                }else{//剩下不完整的块按原先的顺序输出\n                    printf(\"%05d\\n\", node[(i+1)*K].address);\n                    for (int i = n/K * K; i &lt; n; i++) {\n                        printf(\"%05d %d \", node[i].address, node[i].data);\n                        if (i &lt; n - 1) {\n                            printf(\"%05d\\n\", node[i + 1].address);\n                        }else{\n                            printf(\"-1\\n\");\n                        }\n                    }\n                }\n            }\n        }\n    \n        return 0;\n    }\n</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT B1025/A1074","date":"February 21, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/195/"},"frontmatter":{"title":"PAT A1056"}},"next":{"fields":{"slug":"/old-posts/197/"},"frontmatter":{"title":"PAT A1097"}}},"pageContext":{"id":"01127af7-12b1-5db8-9b7e-98b91e21e5c4","previousPostId":"527547fb-12b3-5f80-9ce2-652abf49b97e","nextPostId":"82fca91f-8c2a-5832-b592-9a3842aa1c82"}},
    "staticQueryHashes": ["2841359383","3257411868"]}