{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/203/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"1b58d610-4b13-5aee-943e-db6829f6a97a","excerpt":"The following is from Max Howell @twitter: Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a…","html":"<p>The following is from Max Howell @twitter:</p>\n<p>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.</p>\n<p>Now it’s your turn to prove that YOU CAN invert a binary tree!</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line gives a positive integer N (&#x3C;=10) which is the total number of nodes in the tree — and hence the nodes are numbered from 0 to N-1. Then N lines follow, each corresponds to a node from 0 to N-1, and gives the indices of the left and right children of the node. If the child does not exist, a ”-” will be put at the position. Any pair of children are separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each test case, print in the first line the level-order, and then in the second line the in-order traversal sequences of the inverted tree. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</p>\n<p>Sample Input:\n8\n1 -</p>\n<ul>\n<li>\n<ul>\n<li></li>\n</ul>\n</li>\n</ul>\n<p>0 -\n2 7</p>\n<ul>\n<li>\n<ul>\n<li></li>\n</ul>\n</li>\n<li>\n<ul>\n<li></li>\n</ul>\n</li>\n</ul>\n<p>5 -\n4 6\nSample Output:\n3 7 2 6 4 0 5 1\n6 5 7 4 3 2 0 1</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    #include \"stack\"\n    #include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int maxn = 30;\n    struct node{\n        int lchild;\n        int rchild;\n    }Node[maxn];\n    bool notRoot[maxn] = {false};//记录是否不是根结点，初始均是根结点\n    int n, num = 0;//n为结点个数，num为当前已经输出的结点个数\n    //print函数输出结点id的编号\n    void print(int id){\n        printf(\"%d\", id);//输出id\n        num++;//已经输出的结点个数+1\n        if (num &lt; n) {\n            printf(\" \");\n        }else{\n            printf(\"\\n\");\n        }\n    }\n    //中序遍历\n    void inOrder(int root){\n        if (root == -1) {\n            return;\n        }\n        inOrder(Node[root].lchild);\n        print(root);\n        inOrder(Node[root].rchild);\n    }\n    //层次遍历\n    void BFS(int root){\n        queue&lt;int> Q;\n        Q.push(root);\n        while (!Q.empty()) {\n            int now = Q.front();\n            Q.pop();\n            print(now);\n            if (Node[now].lchild != -1) Q.push(Node[now].lchild);\n            if (Node[now].rchild != -1) Q.push(Node[now].rchild);\n        }\n    }\n    //后序遍历 用于反转二叉树\n    void postOrder(int root){\n        if (root == -1) {\n            return;\n        }\n        postOrder(Node[root].lchild);\n        postOrder(Node[root].rchild);\n        swap(Node[root].lchild, Node[root].rchild);//交换左右孩子结点\n    }\n    //将输入的字符转换为-1或者结点编号\n    int strToNum(char c){\n        if (c == '-') {\n            return -1;\n        }else{\n            notRoot[c - '0'] = true;//标记c不是根节点\n            return c - '0';\n        }\n    }\n    //寻找根节点\n    int findRoot(){\n        for (int i = 0; i &lt; n; i++) {\n            if (notRoot[i] == false) {\n                return i;//是根节点，返回\n            }\n        }\n        return -1;\n    }\n    int main(){\n        char lchild, rchild;\n        scanf(\"%d\", &amp;n);//结点个数\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%*c%c %c\", &amp;lchild, &amp;rchild);//左右孩子结点\n            Node[i].lchild = strToNum(lchild);\n            Node[i].rchild = strToNum(rchild);\n        }\n        int root = findRoot();\n        postOrder(root);//翻转二叉树\n        BFS(root);\n        num = 0;\n        inOrder(root);\n        return 0;\n    }\n</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1102","date":"February 22, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/202/"},"frontmatter":{"title":"PAT A1086"}},"next":{"fields":{"slug":"/old-posts/205/"},"frontmatter":{"title":"PAT A1053"}}},"pageContext":{"id":"1b58d610-4b13-5aee-943e-db6829f6a97a","previousPostId":"b9273bab-1351-5a77-878f-87da5a7c5228","nextPostId":"3bb79e19-f508-5dde-b45e-d2d1ceb78aba"}},
    "staticQueryHashes": ["2841359383","3257411868"]}