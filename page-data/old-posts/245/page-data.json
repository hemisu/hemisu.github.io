{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/245/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"e16be786-d88d-50a3-bbf8-efee344e4e54","excerpt":"题目描述\n给一棵二叉树的层序遍历序列和中序遍历序列，求这棵二叉树的先序遍历序列和后序遍历序列。 输入\n每个输入文件中一组数据。 第一行一个正整数N（1<=N<=30），代表二叉树的结点个数（结点编号为1N）。接下来两行，每行N个正整数，分别代表二叉树的层序遍历序列和中序遍历序列。数据保证序列中1N…","html":"<p>题目描述\n给一棵二叉树的层序遍历序列和中序遍历序列，求这棵二叉树的先序遍历序列和后序遍历序列。</p>\n<p>输入\n每个输入文件中一组数据。</p>\n<p>第一行一个正整数N（1&#x3C;=N&#x3C;=30），代表二叉树的结点个数（结点编号为1<del>N）。接下来两行，每行N个正整数，分别代表二叉树的层序遍历序列和中序遍历序列。数据保证序列中1</del>N的每个数出现且只出现一次。</p>\n<p>输出\n输出两行，每行N个正整数，分别代表二叉树的先序遍历序列和后序遍历序列。每行末尾不输出额外的空格。</p>\n<p>样例输入\n7\n3 5 4 2 6 7 1\n2 5 3 6 4 7 1\n样例输出\n3 5 2 4 6 7 1\n2 5 6 1 7 4 3</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include &lt;iostream>\n    #include &lt;stdio.h>\n    #include &lt;algorithm>\n    #include &lt;string>\n    #include &lt;vector>\n    #include &lt;queue>\n    using namespace std;\n    const int maxn = 50;\n    struct node{\n        int data;\n        node *lchild, *rchild;\n    };\n    int n, lev[maxn], in[maxn];\n    vector&lt;int> layer, pre, post;\n    node* createTree(vector&lt;int> layer, int inL, int inR){\n        if (layer.size() == 0) {\n            return NULL;\n        }\n        node* root = new node;\n        root->data = layer[0];\n        int k;\n        for (k = inL; k &lt;= inR; k++) {\n            if (layer[0] == in[k]) {//在中序遍历中找到\n                break;\n            }\n        }\n        vector&lt;int> layerLeft;\n        vector&lt;int> layerRight;\n        for (int i = 1; i &lt; layer.size(); i++) {\n            bool isLeft = false;\n            for (int j = inL; j &lt; k; j++) {\n                if (layer[i] == in[j]) {\n                    isLeft = true;\n                }\n            }\n            if (isLeft) {\n                layerLeft.push_back(layer[i]);\n            }else{\n                layerRight.push_back(layer[i]);\n            }\n        }\n        root->lchild = createTree(layerLeft, inL, k - 1);\n        root->rchild = createTree(layerRight, k + 1, inR);\n        return root;\n    }\n    void preOrder(node* root, vector&lt;int> &amp;vi) {\n        if (root == NULL) {\n            return;\n        }\n        vi.push_back(root->data);\n        preOrder(root->lchild, vi);\n        preOrder(root->rchild, vi);\n    }\n    void postOrder(node* root, vector&lt;int> &amp;vi) {\n        if (root == NULL) {\n            return;\n        }\n        postOrder(root->lchild, vi);\n        postOrder(root->rchild, vi);\n        vi.push_back(root->data);\n    }\n    \n    int main() {\n        scanf(\"%d\", &amp;n);\n        for (int i = 0; i &lt; n; i++){\n            scanf(\"%d\", &amp;lev[i]);\n            layer.push_back(lev[i]);\n        }\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%d\", &amp;in[i]);\n        }\n        node* root = NULL;\n        root = createTree(layer, 0, n - 1);\n        preOrder(root, pre);\n        postOrder(root, post);\n        for (int i = 0; i &lt; n; i++) {\n            printf(\"%d\", pre[i]);\n            if (i &lt; n - 1) printf(\" \");\n            else printf(\"\\n\");\n        }\n        for (int i = 0; i &lt; n; i++) {\n            printf(\"%d\", post[i]);\n            if (i &lt; n - 1) printf(\" \");\n            else printf(\"\\n\");\n        }\n        return 0;\n    }\n</code></pre></div>","tableOfContents":"","frontmatter":{"title":"2.28模拟题 problem3 还原二叉树","date":"March 01, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/244/"},"frontmatter":{"title":"2.28模拟题 problem2 进击的二叉查找树"}},"next":{"fields":{"slug":"/old-posts/247/"},"frontmatter":{"title":"2.28模拟题 problem1 判断三角形"}}},"pageContext":{"id":"e16be786-d88d-50a3-bbf8-efee344e4e54","previousPostId":"53578c83-781e-5591-881b-0caf94b81d11","nextPostId":"69cd6618-bd18-501c-87ff-002d7764611b"}},
    "staticQueryHashes": ["2841359383","3257411868"]}