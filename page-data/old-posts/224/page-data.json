{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/224/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"33a30b28-6891-583b-b7f0-adf21f278abd","excerpt":"One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between A and B, we say that A and B is related. The…","html":"<p>One way that the police finds the head of a gang is to check people’s phone calls. If there is a phone call between A and B, we say that A and B is related. The weight of a relation is defined to be the total time length of all the phone calls made between the two persons. A “Gang” is a cluster of more than 2 persons who are related to each other with total relation weight being greater than a given threshold K. In each gang, the one with maximum total weight is the head. Now given a list of phone calls, you are supposed to find the gangs and the heads.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains two positive numbers N and K (both less than or equal to 1000), the number of phone calls and the weight threthold, respectively. Then N lines follow, each in the following format:</p>\n<p>Name1 Name2 Time</p>\n<p>where Name1 and Name2 are the names of people at the two ends of the call, and Time is the length of the call. A name is a string of three capital letters chosen from A-Z. A time length is a positive integer which is no more than 1000 minutes.</p>\n<p>Output Specification:</p>\n<p>For each test case, first print in a line the total number of gangs. Then for each gang, print in a line the name of the head and the total number of the members. It is guaranteed that the head is unique for each gang. The output must be sorted according to the alphabetical order of the names of the heads.</p>\n<p>Sample Input 1:\n8 59\nAAA BBB 10\nBBB AAA 20\nAAA CCC 40\nDDD EEE 5\nEEE DDD 70\nFFF GGG 30\nGGG HHH 20\nHHH FFF 10\nSample Output 1:\n2\nAAA 3\nGGG 3\nSample Input 2:\n8 70\nAAA BBB 10\nBBB AAA 20\nAAA CCC 40\nDDD EEE 5\nEEE DDD 70\nFFF GGG 30\nGGG HHH 20\nHHH FFF 10\nSample Output 2:\n0</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    #include \"math.h\"\n    #include \"string.h\"\n    #include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    //#include \"set\"\n    #include \"map\"\n    //#include \"stack\"\n    #include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int maxn = 2010;//总人数\n    const int INF = 1000000000;//无穷大\n    \n    map&lt;int, string> intToString;//编号->姓名\n    map&lt;string, int> stringToInt;//姓名->编号\n    map&lt;string, int> Gang;//head->人数\n    int G[maxn][maxn] = {0}, weight[maxn] = {0};//邻接矩阵G，点权weight\n    int n, k, numPerson = 0;//边数n, 下限k, 总人数numPerson\n    bool vis[maxn] = {false};//标记是否被访问\n    \n    //DFS函数访问单个连通块，nowVisit为当前访问的编号\n    //head为头目，numMember为成员编号，totoalValue为连通块的总边权\n    void DFS(int nowVisit, int&amp; head, int&amp; numMember, int&amp; totalValue){\n        numMember++;//成员人数加1\n        vis[nowVisit] = true;//标记nowVisit已访问\n        if (weight[nowVisit] > weight[head]) {\n            head = nowVisit;//换老大了\n        }\n        for (int i = 0; i &lt; numPerson; i++) {//枚举所有人\n            if (G[nowVisit][i] > 0) {//如果从nowVisit能达到i\n                totalValue += G[nowVisit][i];//连通块的总边权增加该边权\n                G[nowVisit][i] = G[i][nowVisit] = 0;//删除这条边，防止回头\n                if (vis[i] == false) {\n                    DFS(i, head, numMember, totalValue);\n                }\n            }\n        }\n    }\n    //DFSTrave函数遍历整个图，获取每个连通块的信息\n    void DFSTrave(){\n        for (int i = 0; i &lt; numPerson; i++) {//枚举所有人\n            if (vis[i] == false) {\n                int head = i, numMember = 0, totalValue = 0;//头目、成员数目，总边权\n                DFS(i, head, numMember, totalValue);\n                if (numMember > 2 &amp;&amp; totalValue > k) {\n                    //head人数为numMember\n                    Gang[intToString[head]] = numMember;\n                }\n            }\n        }\n    }\n    //change函数返回姓名str对应的编号\n    int change(string str){\n        if (stringToInt.find(str) != stringToInt.end()) {//如果str已经出现过\n            return stringToInt[str];\n        }else{\n            stringToInt[str] = numPerson;//str的编号为strPerson\n            intToString[numPerson] = str;//建立对应关系\n            return numPerson++;\n        }\n    }\n    \n    int main(){\n        int w;\n        string str1, str2;\n        cin >> n >> k;\n        for (int i = 0; i &lt; n; i++) {\n            cin >> str1 >> str2 >> w;//输入两个边的端点和点权\n            int id1 = change(str1);\n            int id2 = change(str2);\n            weight[id1] += w;\n            weight[id2] += w;\n            G[id1][id2] += w;\n            G[id2][id1] += w;\n        }\n        DFSTrave();//遍历整个图所有连通块，获取gang的信息\n        cout &lt;&lt; Gang.size() &lt;&lt; endl;//gang的个数\n        map&lt;string, int>::iterator it;\n        for (it = Gang.begin(); it != Gang.end(); it++) {//遍历所有gang\n            cout &lt;&lt; it->first &lt;&lt; \" \" &lt;&lt; it->second &lt;&lt;endl;\n        }\n        return 0;\n    }\n</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1034","date":"February 24, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/220/"},"frontmatter":{"title":"PAT A1098 . Insertion or Heap Sort (25)"}},"next":{"fields":{"slug":"/old-posts/225/"},"frontmatter":{"title":"PAT A1076"}}},"pageContext":{"id":"33a30b28-6891-583b-b7f0-adf21f278abd","previousPostId":"d1b1f874-469c-52bc-94f0-1436cdb3bd11","nextPostId":"45f2bb18-32c7-5c16-ad36-a16a5a309499"}},
    "staticQueryHashes": ["2841359383","3257411868"]}