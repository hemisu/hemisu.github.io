{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/199/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"6a9cf91f-9e6f-5669-926a-425f683ed9c9","excerpt":"The K-P factorization of a positive integer N is to write N as the sum of the P-th power of K positive integers. You are supposed to write a program to find the…","html":"<p>The K-P factorization of a positive integer N is to write N as the sum of the P-th power of K positive integers. You are supposed to write a program to find the K-P factorization of N for any positive integers N, K and P.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case which gives in a line the three positive integers N (&#x3C;=400), K (&#x3C;=N) and P (1&#x3C;P&#x3C;=7). The numbers in a line are separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each case, if the solution exists, output in the format:</p>\n<p>N = n1^P + … nK^P</p>\n<p>where ni (i=1, … K) is the i-th factor. All the factors must be printed in non-increasing order.</p>\n<p>Note: the solution may not be unique. For example, the 5-2 factorization of 169 has 9 solutions, such as 122 + 42 + 22 + 22 + 12, or 112 + 62 + 22 + 22 + 22, or more. You must output the one with the maximum sum of the factors. If there is a tie, the largest factor sequence must be chosen — sequence { a1, a2, … aK } is said to be larger than { b1, b2, … bK } if there exists 1&#x3C;=L&#x3C;=K such that ai=bi for i<L and aL>bL</p>\n<p>If there is no solution, simple output “Impossible”.</p>\n<p>Sample Input 1:\n169 5 2\nSample Output 1:\n169 = 6^2 + 6^2 + 6^2 + 6^2 + 5^2\nSample Input 2:\n169 167 3\nSample Output 2:\nImpossible</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    //#include \"stack\"\n    //#include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    //n, k, p如题所述，maxFacSum记录最大底数之和\n    int n, k, p, maxFacsum = -1;\n    //fac记录了0^p, 1^p...i^p ,使i^p为不超过n的最大数\n    //ans存放最优底数列,temp存放递归中的临时底数数列\n    vector&lt;int> fac, ans, temp;\n    //power 函数计算x^p\n    int power(int x){\n        int ans = 1;\n        for (int i = 0; i &lt; p; i++) {\n            ans *= x;\n        }\n        return ans;\n    }\n    //init函数预处理fac数组，注意把0也存进去\n    void init(){\n        int i = 0, temp = 0;\n        while (temp &lt;= n) {//当i^p没有超过n时，不断把i^p加入fac\n            fac.push_back(temp);\n            temp = power(++i);\n        }\n    }\n    //dfs函数，当前访问fac[index], nowK为当前选中个数\n    //sum为当前选中数之和，facSum为当前选中底数之和\n    void DFS(int index, int nowK, int sum, int facSum){\n        if (sum == n &amp;&amp; nowK == k) {//找到一个满足的序列\n            if (facSum > maxFacsum) {//如果底数之和更大\n                ans = temp;\n                maxFacsum = facSum;\n            }\n            return;\n        }\n        if (sum > n || nowK > k) return;//这种情况不会产生答案，直接返回\n        if(index - 1 >= 0){//fac[0]不需要选择\n            temp.push_back(index);//把底数index加入临时序列temp\n            DFS(index, nowK + 1, sum + fac[index], facSum + index);//\"选\"的分支\n            temp.pop_back();//\"选\"的分支结束后把刚加进去的数pop掉\n            DFS(index - 1, nowK, sum, facSum);//\"不选\"的分支\n        }\n    }\n    int main(){\n        scanf(\"%d%d%d\", &amp;n, &amp;k, &amp;p);\n        init();//初始化fac数组\n        DFS(fac.size() - 1, 0, 0, 0);//从fac的最后一位开始往前搜索\n        if (maxFacsum == -1) {\n            printf(\"Impossible\\n\");\n        }else{\n            printf(\"%d = %d^%d\", n, ans[0], p);//输出ans结果\n            for (int i = 1; i &lt; ans.size(); i++) {\n                printf(\" + %d^%d\", ans[i], p);\n            }\n        }\n        \n        return 0;\n    }\n</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1103","date":"February 22, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/197/"},"frontmatter":{"title":"PAT A1097"}},"next":{"fields":{"slug":"/old-posts/200/"},"frontmatter":{"title":"PAT A1091"}}},"pageContext":{"id":"6a9cf91f-9e6f-5669-926a-425f683ed9c9","previousPostId":"82fca91f-8c2a-5832-b592-9a3842aa1c82","nextPostId":"3b912a9b-64d7-5214-95f1-6a8d21ed4c14"}},
    "staticQueryHashes": ["2841359383","3257411868"]}