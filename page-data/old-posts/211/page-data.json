{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/211/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"e79047c7-9f08-5e85-b369-efafe4c409ee","excerpt":"A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.\nInput Each input file contains one test…","html":"<p>A family hierarchy is usually presented by a pedigree tree. Your job is to count those family members who have no child.\nInput</p>\n<p>Each input file contains one test case. Each case starts with a line containing 0 &#x3C; N &#x3C; 100, the number of nodes in a tree, and M (&#x3C; N), the number of non-leaf nodes. Then M lines follow, each in the format:</p>\n<p>ID K ID[1] ID[2] … ID[K]\nwhere ID is a two-digit number representing a given non-leaf node, K is the number of its children, followed by a sequence of two-digit ID’s of its children. For the sake of simplicity, let us fix the root ID to be 01.\nOutput</p>\n<p>For each test case, you are supposed to count those family members who have no child for every seniority level starting from the root. The numbers must be printed in a line, separated by a space, and there must be no extra space at the end of each line.</p>\n<p>The sample case represents a tree with only 2 nodes, where 01 is the root and 02 is its only child. Hence on the root 01 level, there is 0 leaf node; and on the next level, there is 1 leaf node. Then we should output “0 1” in a line.</p>\n<p>Sample Input\n2 1\n01 1 02\nSample Output\n0 1</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    #include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    //#include \"stack\"\n    #include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int maxn = 110;\n    int n, m, maxDepth = 0;\n    int countleaf[maxn] = {0};\n    struct node{\n        vector&lt;int> child;\n    }Node[maxn];\n    void DFS(int index, int depth){\n        maxDepth = max(maxDepth , depth);\n        if (Node[index].child.size() == 0) {//叶子结点\n            countleaf[depth]++;\n            return;\n        }\n        for (int i = 0; i &lt; Node[index].child.size(); i++) {\n            DFS(Node[index].child[i], depth + 1);\n        }\n    }\n    int main(){\n        scanf(\"%d%d\", &amp;n, &amp;m);\n        for (int i = 0; i &lt; m ; i++) {\n            int id, k;\n            scanf(\"%d%d\", &amp;id, &amp;k);\n            for (int j = 0; j &lt; k; j++) {\n                int child;\n                scanf(\"%d\", &amp;child);\n                Node[id].child.push_back(child);\n            }\n        }\n        DFS(1,0);\n        for (int i = 0; i &lt;= maxDepth; i++) {\n            printf(\"%d\", countleaf[i]);\n            if (i &lt; maxDepth) printf(\" \");\n        }\n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1004","date":"February 23, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/210/"},"frontmatter":{"title":"PAT A1106"}},"next":{"fields":{"slug":"/old-posts/212/"},"frontmatter":{"title":"PAT A1043"}}},"pageContext":{"id":"e79047c7-9f08-5e85-b369-efafe4c409ee","previousPostId":"b77b4e5e-1bb3-500f-8b27-cf6d11a375f7","nextPostId":"83cf2b5c-ae4d-5be0-9687-eab7e449c8b5"}},
    "staticQueryHashes": ["2841359383","3257411868"]}