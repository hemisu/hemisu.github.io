{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/202/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"b9273bab-1351-5a77-878f-87da5a7c5228","excerpt":"An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys…","html":"<p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.\n<img src=\"https://www.patest.cn/upload/bs_n9mde9jcnyj.jpg\" alt=\"请输入图片描述\"></p>\n<p>Figure 1\nInput Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains a positive integer N (&#x3C;=30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to N). Then 2N lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p>\n<p>Output Specification:</p>\n<p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p>\n<p>Sample Input:\n6\nPush 1\nPush 2\nPush 3\nPop\nPop\nPush 4\nPop\nPop\nPush 5\nPush 6\nPop\nPop\nSample Output:\n3 4 2 6 5 1</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    #include \"stack\"\n    //#include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int maxn = 50;\n    struct node{\n        int data;\n        node* lchild;\n        node* rchild;\n    };\n    int pre[maxn], in[maxn], post[maxn];//先序，中序以及后序\n    int n;//结点个数\n    \n    //当前二叉树的先序序列区间为[preL, preR],中序序列区间为[inL, inR]\n    //create函数返回根节点\n    node* create(int preL, int preR, int inL, int inR){\n        if (preL > preR) return NULL;\n        node* root = new node;\n        root->data = pre[preL];\n        int k;\n        for (k = inL; k &lt;= inR; k++) {\n            if (in[k] == pre[preL]) break;\n        }\n        int numLeft = k - inL;\n        root->lchild = create(preL + 1, preL + numLeft, inL, k - 1);\n        root->rchild = create(preL + numLeft + 1, preR, k + 1, inR);\n        return root;\n    }\n    int num = 0;//已输出的结点个数\n    void postorder(node* root){\n        //后序遍历\n        if (root == NULL) {\n            return;\n        }\n        postorder(root->lchild);\n        postorder(root->rchild);\n        printf(\"%d\", root->data);\n        num++;\n        if(num &lt; n) printf(\" \");\n    }\n    int main(){\n        scanf(\"%d\", &amp;n);\n        char str[5];\n        stack&lt;int> st;\n        int x, preIndex = 0, inIndex = 0;//入栈元素、先序序列位置及中序序列位置\n        for (int i = 0; i &lt; 2 * n; i++) {\n            scanf(\"%s\", str);\n            if (strcmp(str, \"Push\") == 0) {//入栈\n                scanf(\"%d\", &amp;x);\n                pre[preIndex++] = x;\n                st.push(x);\n            }else{\n                in[inIndex++] = st.top();\n                st.pop();\n            }\n        }\n        node* root = create(0, n-1, 0, n-1);\n        postorder(root);\n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1086","date":"February 22, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/201/"},"frontmatter":{"title":"PAT A1020"}},"next":{"fields":{"slug":"/old-posts/203/"},"frontmatter":{"title":"PAT A1102"}}},"pageContext":{"id":"b9273bab-1351-5a77-878f-87da5a7c5228","previousPostId":"2638c14c-d271-548e-aee1-b9d804202df1","nextPostId":"1b58d610-4b13-5aee-943e-db6829f6a97a"}},
    "staticQueryHashes": ["2841359383","3257411868"]}