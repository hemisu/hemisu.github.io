{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/252/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"9664c564-3e9c-53d7-9de7-e4a1e50d6490","excerpt":"…","html":"<p><strong>题目描述</strong>\n“万妖穴中有若干小穴，每处小穴中皆有一只恶妖。小穴外设有封印，汝需消灭指定几处小穴中的恶妖方能解除该小穴封印，进而消灭穴中恶妖。”</p>\n<p>“此处石壁所刻便是万妖穴中各穴的封印解除关系。”</p>\n<p>“万妖穴中或有部分小穴未设封印，汝可以此作为突破口。”</p>\n<p>“吾将根据石壁所示，将各穴消灭顺序给予汝，汝自珍重。”</p>\n<p><strong>输入</strong>\n每个输入文件中一组数据。</p>\n<p>第一行两个正整数N、M（1&#x3C;=N&#x3C;=1000，0&#x3C;=M&#x3C;=N*(N-1)），表示万妖穴中小穴的个数及封印解除关系的条数。</p>\n<p>接下来M行，每行两个整数a、b，表示小穴b封印的解除依赖于消灭小穴a中的恶妖。假设N处小穴的编号分别是0~N-1。数据保证a不等于b，且每组封印解除关系a b最多出现一次。</p>\n<p><strong>输出</strong>\n如果能够消灭所有小穴，那么输出一行YES，并在第二行给出用空格隔开的N处小穴的消灭顺序（此处规定，总是消灭当前能消灭的编号最小的小穴）；如果不能消灭所有小穴，那么输出一行NO，并在第二行给出无法解除封印的小穴个数。行末均不允许输出多余的空格。</p>\n<p>样例输入和输出那里贴不了多个case（提交的程序会强行测试sample），所以直接放这里吧\n<strong>input:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// case 1\n3 3\n0 1\n0 2\n2 1\n// case 2\n4 5\n0 1\n0 2\n0 3\n2 1\n1 2</code></pre></div>\n<p><strong>output:</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// case 1\nYES\n0 2 1\n// case 2\nNO\n2</code></pre></div>\n<p>程序如下：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    const int MAXV = 1010;\n    int n, m, inDegree[MAXV];\n    vector&lt;int> G[MAXV],Q;\n    int topologicalSort(){\n        int num = 0;\n        priority_queue&lt;int,vector&lt;int>,greater&lt;int>> q;\n        for (int i = 0; i &lt; n; i++) {\n            if (inDegree[i] == 0) {\n                q.push(i);//入度为0入队列\n            }\n        }\n        while (!q.empty()) {\n            int u = q.top();\n            Q.push_back(u);\n            q.pop();\n            for (int i = 0; i &lt; G[u].size(); i++) {\n                int v = G[u][i];\n                inDegree[v]--;//入度减少\n                if (inDegree[v] == 0) {\n                    q.push(v);//入度为0，加入队列\n                }\n            }\n            num++;\n        }\n        return num;//返回拓扑结点个数\n    }\n    int main(){\n        scanf(\"%d%d\",&amp;n, &amp;m);\n        memset(inDegree, 0, sizeof(inDegree));//初始化\n        int u, v;\n        for (int i = 0 ; i &lt; m; i++) {\n            scanf(\"%d%d\", &amp;u, &amp;v);\n            G[u].push_back(v);\n            inDegree[v]++;//入度++\n        }\n        int topological = topologicalSort();\n        if (topological == n) {//封印解除！\n            printf(\"YES\\n\");\n            for (int i = 0; i &lt; n; i++) {\n                printf(\"%d\", Q[i]);\n                if (i &lt; n - 1) {\n                    printf(\" \");\n                }\n            }\n        }else{\n            printf(\"NO\\n%d\\n\", n - topological);\n        }\n        return 0;\n    }</code></pre></div>\n<p>题目中要求『此处规定，总是消灭当前能消灭的编号最小的小穴』\n所以采用优先队列</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    priority_queue&lt;int, vector&lt;int>, greater&lt;int>> q;</code></pre></div>\n<p>下面给出一组测试数据</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">//input\n\n     6 5\n     0 1\n     0 2\n     1 5\n     1 3\n     1 4\n\n//output\n\n    YES\n    0 1 2 3 4 5</code></pre></div>","tableOfContents":"","frontmatter":{"title":"3.1模拟题 problem2 万妖穴","date":"March 02, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/251/"},"frontmatter":{"title":"3.1模拟题 problem3 某计算器的超电磁炮"}},"next":{"fields":{"slug":"/old-posts/254/"},"frontmatter":{"title":"3.1模拟题 problem4 上帝视角"}}},"pageContext":{"id":"9664c564-3e9c-53d7-9de7-e4a1e50d6490","previousPostId":"93722f25-24a0-59d9-abb0-2533f0f414b9","nextPostId":"bd195b5f-9807-5ee1-9d29-4cd06b6c0cf6"}},
    "staticQueryHashes": ["2841359383","3257411868"]}