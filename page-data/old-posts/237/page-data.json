{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/237/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"1299150c-7883-54d3-aaba-552145566b40","excerpt":"Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most…","html":"<p>Indeed there are many different tourist routes from our city to Rome. You are supposed to find your clients the route with the least cost while gaining the most happiness.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains 2 positive integers N (2&#x3C;=N&#x3C;=200), the number of cities, and K, the total number of routes between pairs of cities; followed by the name of the starting city. The next N-1 lines each gives the name of a city and an integer that represents the happiness one can gain from that city, except the starting city. Then K lines follow, each describes a route between two cities in the format “City1 City2 Cost”. Here the name of a city is a string of 3 capital English letters, and the destination is always ROM which represents Rome.</p>\n<p>Output Specification:</p>\n<p>For each test case, we are supposed to find the route with the least cost. If such a route is not unique, the one with the maximum happiness will be recommended. If such a route is still not unique, then we output the one with the maximum average happiness — it is guaranteed by the judge that such a solution exists and is unique.</p>\n<p>Hence in the first line of output, you must print 4 numbers: the number of different routes with the least cost, the cost, the happiness, and the average happiness (take the integer part only) of the recommended route. Then in the next line, you are supposed to print the route in the format “City1->City2->…->ROM”.</p>\n<p>Sample Input:\n6 7 HZH\nROM 100\nPKN 40\nGDN 55\nPRS 95\nBLN 80\nROM GDN 1\nBLN ROM 1\nHZH PKN 1\nPRS ROM 2\nBLN HZH 2\nPKN GDN 1\nHZH PRS 1\nSample Output:\n3 3 195 97\nHZH->PRS->ROM</p>\n<p>仅用dijstra：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    #include \"math.h\"\n    #include \"string.h\"\n    #include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    #include \"set\"\n    #include \"map\"\n    //#include \"stack\"\n    #include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    const int MAXV = 410;//最大顶点数\n    const int INF = 1000000000;//无穷大\n    //n 城市数目, k 边数, G 邻接矩阵, w 点权\n    //d[]最短距离,dw[]最大点权,num[]最短路径条数\n    //pt[]记录最短路径上的顶点数,pre[]记录前驱\n    int n, k, G[MAXV][MAXV], weight[MAXV];\n    int d[MAXV], w[MAXV], num[MAXV], pt[MAXV], pre[MAXV];\n    bool vis[MAXV] = {false};\n    map&lt;string, int> cityToIndex;\n    map&lt;int, string> indexToCity;\n    \n    void Dijkstra(int s){\n        fill(d, d + MAXV, INF);\n        memset(w, 0, sizeof(w));\n        memset(num, 0, sizeof(num));\n        memset(pt, 0, sizeof(pt));\n        for (int i = 0; i &lt; n; i++) pre[i] = i;//前驱初始化\n        d[s] = 0;\n        w[s] = 0;\n        num[s] = 1;\n        for (int i = 0; i &lt; n; i++) {//循环n次\n            int u = -1, MIN = INF;\n            for (int j = 0; j &lt; n; j++) {\n                if (vis[j] == false &amp;&amp; d[j] &lt; MIN) {\n                    u = j;\n                    MIN = d[j];\n                }\n            }\n            if (u == -1) return;\n            vis[u] = true;\n            for (int v = 0; v &lt; n; v++) {\n                if (vis[v] == false &amp;&amp; G[u][v] != INF) {\n                    if (d[u] + G[u][v] &lt; d[v]) {\n                        d[v] = d[u] + G[u][v];//优化d[v]\n                        w[v] = w[u] + weight[v];\n                        num[v] = num[u];\n                        pt[v] = pt[u] + 1;\n                        pre[v] = u;\n                    }else if (d[u] + G[u][v] == d[v]){\n                        num[v] += num[u];//加最短路径条数\n                        if (w[u] + weight[v] > w[v]) {\n                            w[v] = w[u] + weight[v];\n                            pt[v] = pt[u] + 1;\n                            pre[v] = u;\n                        }else if(w[u] + weight[v] == w[v]){\n                            double uAvg = 1.0 * (w[u] + weight[v]) / (pt[u] + 1);\n                            double vAvg = 1.0 * w[v] / pt[v];\n                            if (uAvg > vAvg) {\n                                pt[v] = pt[u] + 1;\n                                pre[v] = u;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    void printPath(int v){\n        if (v == 0) {\n            cout &lt;&lt; indexToCity[v];\n            return;\n        }\n        printPath(pre[v]);\n        cout &lt;&lt;\"->\"&lt;&lt;indexToCity[v];\n    }\n    int main(){\n        string start, str1, str2;\n        cin >> n >> k >> start;\n        cityToIndex[start] = 0;\n        indexToCity[0] = start;\n        for (int i = 1; i &lt;= n - 1; i++) {\n            cin >> str1 >> weight[i];//读入happy值，点权\n            cityToIndex[str1] = i;\n            indexToCity[i] = str1;\n        }\n        fill(G[0], G[0] + MAXV * MAXV, INF);//初始化图G\n        for (int i = 0; i &lt; k; i++){\n            cin >> str1 >> str2;\n            int c1 = cityToIndex[str1], c2 = cityToIndex[str2];\n            cin >> G[c1][c2];\n            G[c2][c1] = G[c1][c2];//无向边\n        }\n        Dijkstra(0);\n        int rom = cityToIndex[\"ROM\"];\n        printf(\"%d %d %d %d\\n\", num[rom], d[rom], w[rom], w[rom]/pt[rom]);\n        printPath(rom);\n        return 0;\n    }</code></pre></div>\n<p>dijstra + dfs:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    #include \"math.h\"\n    #include \"string.h\"\n    #include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    #include \"set\"\n    #include \"map\"\n    //#include \"stack\"\n    #include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    const int MAXV = 410;//最大顶点数\n    const int INF = 1000000000;//无穷大\n    //n 城市数目, k 边数, G 邻接矩阵, w 点权\n    //d[]最短距离,numPath记录最短路径条数\n    //maxW记录最大点权之和，maxAvg为最大平均点权\n    int n, k, G[MAXV][MAXV], weight[MAXV];\n    int d[MAXV], numPath = 0, maxW = 0;\n    double maxAvg = 0;\n    bool vis[MAXV] = {false};\n    vector&lt;int> pre[MAXV];\n    vector&lt;int> tempPath, path;\n    map&lt;string, int> cityToIndex;\n    map&lt;int, string> indexToCity;\n    \n    void Dijstra(int s){//起点s\n        fill(d, d + MAXV, INF);\n        d[s] = 0;\n        for (int i = 0; i &lt; n; i++) {\n            int u = -1, MIN = INF;\n            for (int j = 0; j &lt; n; j++) {\n                if (vis[j] == false &amp;&amp; d[j] &lt; MIN) {\n                    u = j;\n                    MIN = d[j];\n                }\n            }\n            if (u == -1) return;\n            vis[u] = true;\n            for (int v = 0; v &lt; n; v++) {\n                if (vis[v] == false &amp;&amp; G[u][v] != INF) {\n                    if (d[u] + G[u][v] &lt; d[v]) {\n                        d[v] = d[u] + G[u][v];\n                        pre[v].clear();\n                        pre[v].push_back(u);\n                    } else if(d[u] + G[u][v] == d[v]){\n                        pre[v].push_back(u);\n                    }\n                }\n            }\n        }\n    }\n    \n    void DFS(int v){\n        if (v == 0) {\n            tempPath.push_back(v);\n            numPath++;\n            int tempW = 0;//临时路径tempPath的点权之和\n            for (int i = tempPath.size() - 2; i >= 0; i--) {\n                int id = tempPath[i];\n                tempW += weight[id];\n            }\n            double tempAvg = 1.0 * tempW / (tempPath.size() - 1);\n            if (tempW > maxW) {//当前点权和更大\n                maxW = tempW;\n                maxAvg = tempAvg;\n                path = tempPath;\n            }else if (tempW == maxAvg &amp;&amp; tempAvg > maxAvg){\n                maxAvg = tempAvg;\n                path = tempPath;\n            }\n            tempPath.pop_back();\n            return;\n        }\n        tempPath.push_back(v);\n        for (int i = 0; i &lt; pre[v].size(); i++) {\n            DFS(pre[v][i]);\n        }\n        tempPath.pop_back();\n    }\n    \n    int main(){\n        string start, city1, city2;\n        cin >> n >> k >> start;\n        cityToIndex[start] = 0;\n        indexToCity[0] = start;\n        for (int i = 1; i &lt;= n -1; i++) {\n            cin >> city1 >> weight[i];\n            cityToIndex[city1] = i;\n            indexToCity[i] = city1;\n        }\n        fill(G[0], G[0] + MAXV * MAXV, INF);\n        for (int i = 0; i &lt; k; i++) {\n            cin >> city1 >> city2;\n            int c1 = cityToIndex[city1], c2 = cityToIndex[city2];\n            cin >> G[c1][c2];\n            G[c2][c1] = G[c1][c2];\n        }\n        Dijstra(0);\n        int rom = cityToIndex[\"ROM\"];\n        DFS(rom);\n        printf(\"%d %d %d %d\\n\", numPath, d[rom], maxW, (int)maxAvg);\n        for (int i = path.size() - 1; i >= 0; i--) {\n            cout &lt;&lt; indexToCity[path[i]];\n            if (i > 0) {\n                cout &lt;&lt;\"->\";\n            }\n        }\n        return 0;\n    }\n</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1087","date":"February 26, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/235/"},"frontmatter":{"title":"PAT A1072"}},"next":{"fields":{"slug":"/old-posts/238/"},"frontmatter":{"title":"PAT A1007 . Maximum Subsequence Sum (25)"}}},"pageContext":{"id":"1299150c-7883-54d3-aaba-552145566b40","previousPostId":"30e976bb-041d-5d44-ac43-001b740f8e53","nextPostId":"c17ef6bd-64e5-5632-85c3-ac9e0b53fabe"}},
    "staticQueryHashes": ["2841359383","3257411868"]}