{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/194/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"a2623964-dc87-5c9b-b7c1-66cc98086d68","excerpt":"Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of…","html":"<p>Given a stack which can keep M numbers at most. Push N numbers in the order of 1, 2, 3, …, N and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if M is 5 and N is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): M (the maximum capacity of the stack), N (the length of push sequence), and K (the number of pop sequences to be checked). Then K lines follow, each contains a pop sequence of N numbers. All the numbers in a line are separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p>\n<p>Sample Input:\n5 7 5\n1 2 3 4 5 6 7\n3 2 1 7 5 6 4\n7 6 5 4 3 2 1\n5 6 4 3 7 2 1\n1 7 6 5 4 3 2\nSample Output:\nYES\nNO\nNO\nYES\nNO</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    #include \"stdlib.h\"\n    //#include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    #include \"stack\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int maxn = 1010;\n    int arr[maxn];//保存题目给定的出栈序列\n    stack&lt;int> st;//定义栈st 用以存放int型元素\n    int main(){\n        int m, n, T;\n        scanf(\"%d%d%d\", &amp;m, &amp;n, &amp;T);\n        while (T--) {\n            while (!st.empty()) {//清空栈\n                st.pop();\n            }\n            for (int i = 1; i &lt;= n; i++) {\n                scanf(\"%d\", &amp;arr[i]);\n            }\n            int current = 1;//指向出栈序列中的待出栈元素\n            bool flag = true;\n            for (int i = 1; i &lt;= n; i++) {\n                st.push(i);//把i压入栈\n                if (st.size() > m) {//如果此时栈中元素大于容量m，则序列非法\n                    flag = false;\n                    break;\n                }\n                //栈顶元素与出栈序列当前位置的元素相同时\n                while (!st.empty() &amp;&amp; st.top() == arr[current]) {\n                    st.pop();//反复弹栈并令current++\n                    current++;\n                }\n            }\n            if (st.empty() == true &amp;&amp; flag == true) {\n                printf(\"YES\\n\");\n            }else{\n                printf(\"NO\\n\");\n            }\n        }\n        \n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1051","date":"February 21, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/192/"},"frontmatter":{"title":"PAT A1052"}},"next":{"fields":{"slug":"/old-posts/195/"},"frontmatter":{"title":"PAT A1056"}}},"pageContext":{"id":"a2623964-dc87-5c9b-b7c1-66cc98086d68","previousPostId":"736ceb23-2d56-506a-9bfb-a812dd82579d","nextPostId":"527547fb-12b3-5f80-9ce2-652abf49b97e"}},
    "staticQueryHashes": ["2841359383","3257411868"]}