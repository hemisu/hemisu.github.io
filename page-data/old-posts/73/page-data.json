{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/73/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"74cd43bd-c13e-5a68-9802-232f54c2fb35","excerpt":"某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。 这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过200岁的老人，而今天是2014年9月6日，所以超过200岁的生日和未出生的生日都是不合理的，应该被过滤掉。 输入格式： 输入在第一行给出正整数N，取值在(…","html":"<p>某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。</p>\n<p>这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过200岁的老人，而今天是2014年9月6日，所以超过200岁的生日和未出生的生日都是不合理的，应该被过滤掉。</p>\n<p>输入格式：</p>\n<p>输入在第一行给出正整数N，取值在(0, 105]；随后N行，每行给出1个人的姓名（由不超过5个英文字母组成的字符串）、以及按“yyyy/mm/dd”（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。</p>\n<p>输出格式：</p>\n<p>在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。</p>\n<p>输入样例：\n5\nJohn 2001/05/12\nTom 1814/09/06\nAnn 2121/01/30\nJames 1814/09/05\nSteve 1967/11/20\n输出样例：\n3 Tom John</p>\n<p>算法笔记代码：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> #include \"stdio.h\"\n    //#include \"algorithm\"\n    //using namespace std;\n    struct person{\n        char name[10];\n        int year, month, day;\n    } oldest, youngest, left, right;\n    bool LessEqu(person a, person b){\n        if (a.year != b.year) {\n            return a.year &lt;= b.year;\n        }else if (a.month != b.month){\n            return a.month &lt;= b.month;\n        }else{\n            return a.day &lt;= b.day;\n        }\n    }\n    bool MoreEqu(person a, person b){\n        if (a.year != b.year) {\n            return a.year >= b.year;\n        }else if (a.month != b.month){\n            return a.month >= b.month;\n        }else{\n            return a.day >= b.day;\n        }\n    }\n    void init(){\n        youngest.year = left.year = 1814;\n        oldest.year = right.year = 2014;\n        youngest.month = oldest.month = left.month = right.month = 9;\n        youngest.day = oldest.day = left.day = right.day = 6;\n    }\n    int main(){\n        init();\n        int n,num;\n        person temp;\n        scanf(\"%d\", &amp;n);\n        for (int i = 0; i &lt; n; i++) {\n            scanf(\"%s %d/%d/%d\", temp.name, &amp;temp.year, &amp;temp.month, &amp;temp.day);\n            if (MoreEqu(temp, left) &amp;&amp; LessEqu(temp, right)) {\n                num++;\n                if (LessEqu(temp, oldest)) {\n                    oldest = temp;\n                }\n                if (MoreEqu(temp, youngest)) {\n                    youngest = temp;\n                }\n            }\n        }\n        if (num == 0) {\n            printf(\"0\\n\");\n        }else\n        {\n            printf(\"%d %s %s\", num, oldest.name, youngest.name);\n        }\n        return 0;\n    }</code></pre></div>\n<p>收获：\n有可能存在所有人的日期都不在合法的区间内的情况，这是必须特判输出0，否则会因为后面输出多的空格而返回格式错误。\n在使用新读入的日期来更新最大日期和最小日期时，有可能同时更新最大日期和最小日期，因此不能使用if……else的写法来选择一个更新。\n日期比较函数只写一个的写法会导致边界日期处理出现问题。</p>","tableOfContents":"","frontmatter":{"title":"PAT B1028","date":"February 01, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/71/"},"frontmatter":{"title":"PAT B1041"}},"next":{"fields":{"slug":"/old-posts/74/"},"frontmatter":{"title":"PAT B1032"}}},"pageContext":{"id":"74cd43bd-c13e-5a68-9802-232f54c2fb35","previousPostId":"8c7fb56e-93cb-5043-a855-56ee5f4fe5f1","nextPostId":"1aa81a88-e1cf-5afe-a659-4a315cf3c7b1"}},
    "staticQueryHashes": ["2841359383","3257411868"]}