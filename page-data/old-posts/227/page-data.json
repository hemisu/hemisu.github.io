{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/227/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"1266d35f-e566-5ba3-8483-7b8f9574e988","excerpt":"A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that…","html":"<p>A graph which is connected and acyclic can be considered a tree. The height of the tree depends on the selected root. Now you are supposed to find the root that results in a highest tree. Such a root is called the deepest root.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains a positive integer N (&#x3C;=10000) which is the number of nodes, and hence the nodes are numbered from 1 to N. Then N-1 lines follow, each describes an edge by given the two adjacent nodes’ numbers.</p>\n<p>Output Specification:</p>\n<p>For each test case, print each of the deepest roots in a line. If such a root is not unique, print them in increasing order of their numbers. In case that the given graph is not a tree, print “Error: K components” where K is the number of connected components in the graph.</p>\n<p>Sample Input 1:\n5\n1 2\n1 3\n1 4\n2 5\nSample Output 1:\n3\n4\n5\nSample Input 2:\n5\n1 3\n1 4\n2 5\n3 4\nSample Output 2:\nError: 2 components</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    #include \"math.h\"\n    #include \"string.h\"\n    #include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    #include \"set\"\n    #include \"map\"\n    //#include \"stack\"\n    #include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int N = 10010;\n    vector&lt;int> G[N];//邻接表\n    vector&lt;int> deepestRoot, ans;\n    bool vis[N] = {false};//标记顶点i是否已经被访问\n    int n, maxDepth = -1;\n    \n    //dfs遍历v所在的连通块\n    void dfs(int v,int depth){\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            deepestRoot.clear();\n            deepestRoot.push_back(v);\n            \n        }else if(depth == maxDepth){\n            deepestRoot.push_back(v);\n        }\n        vis[v] = true;//v点被访问\n        for (int i = 0; i &lt; G[v].size(); i++) {\n            if (vis[G[v][i]] == false) {//如果顶点G[v][i]未被访问\n                dfs(G[v][i], depth + 1);\n            }\n        }\n    }\n    int block = 0;\n    void dfstrave(){\n        for (int i = 1; i &lt;= n; i++) {\n            if (vis[i] == false) {\n                dfs(i, 0);\n                block++;\n            }\n        }\n    }\n    \n    int main(){\n        scanf(\"%d\", &amp;n);\n        for (int i = 1; i &lt;= n - 1; i++) {\n            int a, b;\n            scanf(\"%d%d\", &amp;a, &amp;b);\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        dfstrave();\n        memset(vis, false, sizeof(vis));\n        set&lt;int> sRoot;\n        if (block == 1) {//是树\n            for (int i = 0 ; i &lt; deepestRoot.size(); i++) {\n                sRoot.insert(deepestRoot[i]);\n            }\n            dfs(deepestRoot[0], 0);\n            for (int i = 0 ; i &lt; deepestRoot.size(); i++) {\n                    sRoot.insert(deepestRoot[i]);\n            }\n            set&lt;int>::iterator it = sRoot.begin();\n            for (; it != sRoot.end() ; it++) {\n                printf(\"%d\\n\", *it);\n            }\n        }else{\n            printf(\"Error: %d components\\n\", block);\n        }\n    \n        return 0;\n    }</code></pre></div>\n<p>并查集版本（算法笔记）：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    #include \"math.h\"\n    #include \"string.h\"\n    #include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    #include \"set\"\n    #include \"map\"\n    //#include \"stack\"\n    #include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    const int N = 110;\n    vector&lt;int> G[N];//邻接表\n    \n    bool isRoot[N];//记录每个结点是否作为某个集合的根结点\n    int father[N];//并查集\n    int findFather(int x){\n        int a = x;\n        while (x != father[x]) {\n            x = father[x];\n        }\n        //路径压缩\n        while (a != father[a]) {\n            int z = a;\n            a = father[a];\n            father[z] = x;\n        }\n        return x;\n    }\n    void Union(int a, int b) {//合并a和b所在的集合\n        int faA = findFather(a);\n        int faB = findFather(b);\n        if (faA != faB) {\n            father[faA] = faB;\n        }\n    }\n    void init(int n){//并查集初始化\n        for (int i = 1; i &lt;= n; i++) {\n            father[i] = i;\n        }\n    }\n    int calBlock(int n){//计算连通块个数\n        int Block = 0;\n        for (int i = 1; i &lt;= n; i++) {\n            isRoot[findFather(i)] = true;//i的根节点是findFather(i)\n        }\n        for (int i = 1; i &lt;= n; i++) {\n            Block += isRoot[i];//累加根结点个数\n        }\n        return Block;\n    }\n    int maxH = 0;//最大高度\n    vector&lt;int> temp, ans;//temp临时存放dfs的最远结点结果，ans保存答案\n    \n    //dfs函数,u为当前访问结点编号，height为当前树高，pre为u的父节点\n    void dfs(int u, int height, int pre){\n        if (height > maxH) {//获得了更大的树高\n            temp.clear();//清空temp\n            temp.push_back(u);//将当前结点u加入temp中\n            maxH = height;//更新最大树高\n        }else if(height == maxH){\n            temp.push_back(u);//加入当前结点到temp中\n        }\n        for (int i = 0; i &lt; G[u].size(); i++) {//遍历u的所有子节点\n            //由于邻接表中存放无向图，因此需要跳过回去的边\n            if (G[u][i] == pre) continue;\n            dfs(G[u][i], height + 1, u);//访问子节点\n        }\n    \n    }\n    \n    int main(){\n        int a, b, n;\n        scanf(\"%d\", &amp;n);\n        init(n);\n        for (int i = 1; i &lt; n; i++) {\n            scanf(\"%d%d\", &amp;a, &amp;b);\n            G[a].push_back(b);//边a->b\n            G[b].push_back(a);//边b->a\n            Union(a, b);//合并a和b所在的集合\n        }\n        int Block = calBlock(n);//计算集合数目\n        if (Block != 1) {//不止一个连通块\n            printf(\"Error: %d components\\n\", Block);\n        } else {\n            dfs(1, 1, -1);//从1号结点开始dfs，初始高度为1\n            ans = temp;//temp为集合A，赋值给ans\n            dfs(ans[0], 1, -1);//从任意一个根节点开始遍历\n            for (int i = 0; i &lt; temp.size(); i++) {\n                ans.push_back(temp[i]);//此时temp为集合b，将其加到ans中\n            }\n            sort(ans.begin(), ans.end());//按编号从小到大排序\n            printf(\"%d\\n\", ans[0]);\n            for (int i = 1; i &lt; ans.size(); i++) {\n                if (ans[i] != ans[i - 1]) {//重复编号不输出\n                    printf(\"%d\\n\", ans[i]);\n                }\n            }\n//        dfs(1, 1, -1);//从1号结点开始dfs，初始高度为1\n//        set&lt;int> setofRoot;\n//        for (int i = 0; i &lt; temp.size(); i++) {\n//            setofRoot.insert(temp[i]);\n//        }\n//        dfs(temp[0], 1, -1);\n//        for (int i = 0; i &lt; temp.size(); i++) {\n//            setofRoot.insert(temp[i]);\n//        }\n//        for (set&lt;int>::iterator it = setofRoot.begin(); it != setofRoot.end(); it++) {\n//            printf(\"%d\\n\", *it);\n//        }\n\n        }\n        return 0;\n    }</code></pre></div>\n<p>注释中是用集合实现deepest root的储存</p>","tableOfContents":"","frontmatter":{"title":"PAT A1021","date":"February 24, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/226/"},"frontmatter":{"title":"PAT A1013"}},"next":{"fields":{"slug":"/old-posts/230/"},"frontmatter":{"title":"PAT A1003"}}},"pageContext":{"id":"1266d35f-e566-5ba3-8483-7b8f9574e988","previousPostId":"00638397-aea6-553d-b5f3-4a0ac204fc30","nextPostId":"20cf6856-0489-5104-8c18-40a4adac6cd4"}},
    "staticQueryHashes": ["2841359383","3257411868"]}