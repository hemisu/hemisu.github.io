{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/218/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"37d161bf-785f-5878-823b-2619c1434c16","excerpt":"输入格式\n输入的第一行有两个正整数n <=100 和m <= 100，分别表示数码宝贝的个数和好朋友的组数，其中数码宝贝的编号为1~n。\n接下来有m行，每行两个正整数a和b，表示数码宝贝a和数码宝贝b是好朋友\n输出格式\n输出一个整数，表示这些数码宝贝可以分成的组数。 样例输入1\n4 2\n1 4\n2 3\n样例输出1…","html":"<p>输入格式\n输入的第一行有两个正整数n &#x3C;=100 和m &#x3C;= 100，分别表示数码宝贝的个数和好朋友的组数，其中数码宝贝的编号为1~n。\n接下来有m行，每行两个正整数a和b，表示数码宝贝a和数码宝贝b是好朋友\n输出格式\n输出一个整数，表示这些数码宝贝可以分成的组数。</p>\n<p>样例输入1\n4 2\n1 4\n2 3\n样例输出1\n2\n样例输入2\n7 5\n1 2\n2 3\n3 1\n1 4\n5 6\n样例输出2\n3</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    #include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    //#include \"stack\"\n    #include \"queue\"\n    #include \"algorithm\"\n    using namespace std;\n    \n    //typedef long long LL;\n    const int maxn= 110;\n    int father[maxn];//存放父亲结点\n    bool isRoot[maxn];//记录每个结点是否作为某个集合的根结点\n    int findFather(int x){//查找x所在集合的根节点\n        int a = x;\n        while (x != father[x]) {\n            x = father[x];\n        }\n        //路径压缩\n        while (a != father[a]) {\n            int z = a;\n            a = father[a];\n            father[z] = x;\n        }\n        return x;\n    }\n    void Union(int a, int b){//合并a和b所在的集合\n        int faA = findFather(a);\n        int faB = findFather(b);\n        if (faA != faB) {\n            father[faA] = faB;\n        }\n    }\n    void init(int n){//初始化father[i]为i，且isRoot[i]为false\n        for (int i = 1; i &lt;= n; i++) {\n            father[i] = i;\n            isRoot[i] = false;\n        }\n    }\n    int main(){\n        int n, m, a, b;\n        scanf(\"%d%d\", &amp;n, &amp;m);\n        init(n);\n        for (int i = 0; i &lt; m; i++) {\n            scanf(\"%d%d\", &amp;a, &amp;b);\n            Union(a, b);\n        }\n        for (int i = 1; i &lt;= n; i++) {\n            isRoot[findFather(i)] = true;\n        }\n        int ans = 0;//记录集合数目\n        for (int i = 1; i &lt;= n; i++) {\n            ans += isRoot[i];\n        }\n        printf(\"%d\", ans);\n        return 0;\n    }\n</code></pre></div>","tableOfContents":"","frontmatter":{"title":"好朋友 - 并查集","date":"February 24, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/216/"},"frontmatter":{"title":"PAT A1066"}},"next":{"fields":{"slug":"/old-posts/219/"},"frontmatter":{"title":"PAT A1107 . Social Clusters"}}},"pageContext":{"id":"37d161bf-785f-5878-823b-2619c1434c16","previousPostId":"aac54947-12b1-511f-b49d-a0bcbcc39aec","nextPostId":"21f7fd8c-e969-5033-9033-99b8be6eff09"}},
    "staticQueryHashes": ["2841359383","3257411868"]}