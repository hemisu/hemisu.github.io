{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/191/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"4e29c056-b8b6-59d3-b1cf-35d26f56b8dc","excerpt":"To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if…","html":"<p>To store English words, one method is to use linked lists and store a word letter by letter. To save some space, we may let the words share the same sublist if they share the same suffix. For example, “loading” and “being” are stored as showed in Figure 1.\n<img src=\"https://www.patest.cn/upload/1w_m16pjsommxz.jpg\" alt=\"请输入图片描述\"></p>\n<p>Figure 1\nYou are supposed to find the starting position of the common suffix (e.g. the position of “i” in Figure 1).</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains two addresses of nodes and a positive N (&#x3C;= 105), where the two addresses are the addresses of the first nodes of the two words, and N is the total number of nodes. The address of a node is a 5-digit positive integer, and NULL is represented by -1.</p>\n<p>Then N lines follow, each describes a node in the format:</p>\n<p>Address Data Next</p>\n<p>where Address is the position of the node, Data is the letter contained by this node which is an English letter chosen from {a-z, A-Z}, and Next is the position of the next node.</p>\n<p>Output Specification:</p>\n<p>For each case, simply output the 5-digit starting position of the common suffix. If the two words have no common suffix, output “-1” instead.</p>\n<p>Sample Input 1:\n11111 22222 9\n67890 i 00002\n00010 a 12345\n00003 g -1\n12345 D 67890\n00002 n 00003\n22222 B 23456\n11111 L 00001\n23456 e 67890\n00001 o 00010\nSample Output 1:\n67890\nSample Input 2:\n00001 00002 4\n00001 a 10001\n10001 s -1\n00002 a 10002\n10002 t -1\nSample Output 2:\n-1</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    //#include \"iostream\"\n    #include \"stdlib.h\"\n    //#include \"vector\"\n    //#include \"set\"\n    //#include \"map\"\n    //#include \"algorithm\"\n    //using namespace std;\n    \n    //typedef long long LL;\n    const int maxn = 100010;\n    struct NODE{\n        char data;//数据域\n        int next;//指针域\n        bool flag;//结点是否在第一条链表中出现\n    }node[maxn];\n    \n    int main(){\n        for (int i = 0; i &lt; maxn; i++) {\n            node[i].flag = false;//没有在第一条链表出现\n        }\n        int s1, s2,n;//s1,s2分别代表两条链表的首地址\n        scanf(\"%d%d%d\", &amp;s1, &amp;s2, &amp;n);\n        int address, next;//结点地址与下一结点地址\n        char data;//数据\n        for (int i = 0 ; i &lt; n; i++) {\n            scanf(\"%d %c %d\", &amp;address, &amp;data, &amp;next);\n            node[address].data = data;\n            node[address].next = next;\n        }\n        int p;\n        for (p = s1; p != -1; p = node[p].next) {\n            node[p].flag = true;//枚举第一条链表的所有结点，令其出现次数为1\n        }\n        for (p = s2; p != -1; p = node[p].next) {\n            //找到第一个已经在第一条链表中出现的结点\n            if (node[p].flag == true) {\n                break;\n            }\n        }\n        if (p != -1) {\n            printf(\"%05d\\n\", p);\n        }else{\n            printf(\"-1\\n\");\n        }\n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1032","date":"February 21, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/187/"},"frontmatter":{"title":"PAT A1022"}},"next":{"fields":{"slug":"/old-posts/192/"},"frontmatter":{"title":"PAT A1052"}}},"pageContext":{"id":"4e29c056-b8b6-59d3-b1cf-35d26f56b8dc","previousPostId":"4a87650f-bf8e-5eb5-af60-35c0ed444bff","nextPostId":"736ceb23-2d56-506a-9bfb-a812dd82579d"}},
    "staticQueryHashes": ["2841359383","3257411868"]}