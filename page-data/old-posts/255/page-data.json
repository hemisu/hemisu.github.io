{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/255/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"ace8c666-9af7-5c72-bb68-8a481839de04","excerpt":"树的生成\n中序序列可以与先序序列、后序序列、层序序列中的任意一个来构建唯一的二叉树。 先序+中序： 后序+中序： 层次+中序：","html":"<p><strong>树的生成</strong>\n中序序列可以与先序序列、后序序列、层序序列中的任意一个来构建唯一的二叉树。</p>\n<p>先序+中序：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    node* create(int preL, int preR, int inL, int inR){\n        if (preL > preR) {\n            return NULL;\n        }\n        node* root = new node;\n        root->data = pre[preL];\n        root->left = root->right = NULL;\n        int k;\n        for (k = inL; k &lt;= inR; k++) {\n            if (root->data == in[k]) {\n                break;//找到根节点\n            }\n        }\n        int numLeft = k - inL;\n        root->left = create(preL + 1, preL + numLeft, inL, k - 1);\n        root->right = create(preL + numLeft, preR, k + 1, inR);\n        return root;\n    }</code></pre></div>\n<p>后序+中序：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    node* create(int postL, int postR, int inL, int inR){\n        if (postL > postR) {\n            return NULL;\n        }\n        node* root = new node;\n        root->data = pre[postR];\n        root->left = root->right = NULL;\n        int k;\n        for (k = inL; k &lt;= inR; k++) {\n            if (root->data == in[k]) {\n                break;//找到根节点\n            }\n        }\n        int numLeft = k - inL;\n        root->left = create(postL, postL + numLeft - 1, inL, k - 1);\n        root->right = create(postL + numLeft, postR - 1, k + 1, inR);\n        return root;\n    }</code></pre></div>\n<p>层次+中序：</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    node* create(vector&lt;int>layer, int inL, int inR){\n        if(layer.size() == 0){\n            return NULL;\n        }\n        node* root = new node;\n        root->data = layer[0];\n        int k;\n        for (k = inL; k &lt;= inR; k++) {\n            if (root->data == in[k]) {\n                break;//找到根结点\n            }\n        }\n        vector&lt;int> leftLayer;\n        vector&lt;int> rightLayer;\n        for (int i = 0; i &lt; layer.size(); i++) {//先从layer里找，因为顺序决定谁是根节点\n            bool isLeft = false;\n            for (int j = inL; j &lt; k; j++) {\n                if (layer[i] == in[j]) {//在中序的左边找到\n                    isLeft = true;//是左子树上的点\n                }\n            }\n            if (isLeft) leftLayer.push_back(layer[i]);\n            else rightLayer.push_back(layer[i]);\n        }\n        root->left = create(leftLayer, inL, k - 1);\n        root->left = create(rightLayer, k + 1, inR);\n        return root;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT重点整理——二叉树生成","date":"March 02, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/254/"},"frontmatter":{"title":"3.1模拟题 problem4 上帝视角"}},"next":{"fields":{"slug":"/old-posts/257/"},"frontmatter":{"title":"PAT A1119 . Pre- and Post-order Traversals (30)"}}},"pageContext":{"id":"ace8c666-9af7-5c72-bb68-8a481839de04","previousPostId":"bd195b5f-9807-5ee1-9d29-4cd06b6c0cf6","nextPostId":"7fd05190-793c-5d9a-a5eb-e889eff0ab76"}},
    "staticQueryHashes": ["2841359383","3257411868"]}