{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/254/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"bd195b5f-9807-5ee1-9d29-4cd06b6c0cf6","excerpt":"题目描述\n给一棵二叉树的层序遍历序列和中序遍历序列，求这棵二叉树的先序遍历序列和后序遍历序列，并给出从右往左、从右上往左下、从上往下分别能看到的结点个数。注意，此处均把二叉树的每条边都设置为等长，角度为4…","html":"<p>题目描述\n给一棵二叉树的层序遍历序列和中序遍历序列，求这棵二叉树的先序遍历序列和后序遍历序列，并给出从右往左、从右上往左下、从上往下分别能看到的结点个数。注意，此处均把二叉树的每条边都设置为等长，角度为45度，因此结点可能在视觉上重叠。所谓从右往左看是指，对同一层的结点，右边的结点会挡住左边的结点，这样同一层结点就只能看到最右边的那一个；同样的，从右上往左下看是指，右上角的结点会挡住左下角45度的结点；从上往下看是指，对同一竖直位置来说，只能看到最上方的结点。</p>\n<p>例如对下图来说，从右往左能看到3个结点，从右上往左下能看到3个结点，从上往下能看到5个结点。</p>\n<p><img src=\"http://www.codeup.cn/upload/201603/image/D.png\" alt=\"请输入图片描述\"></p>\n<p>输入\n每个输入文件中一组数据。</p>\n<p>第一行一个正整数N（1&#x3C;=N&#x3C;=30），代表二叉树的结点个数（结点编号为1~N）。</p>\n<p>接下来两行，每行N个正整数，分别代表二叉树的层序遍历序列和中序遍历序列。数据保证序列中1~N的每个数出现且只出现一次。</p>\n<p>输出\n先输出两行，每行N个正整数，分别代表二叉树的先序遍历序列和后序遍历序列。</p>\n<p>接下来分三行输出从右往左、从右上往左下、从上往下分别能看到的结点个数。</p>\n<p>每行末尾均不允许输出多余的空格。</p>\n<p>样例输入\n7\n1 2 3 4 5 6 7\n4 2 5 1 6 3 7\n样例输出\n1 2 4 5 3 6 7\n4 5 2 6 7 3 1\n3\n3\n5</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include &lt;cstdio>\n    #include &lt;cmath>\n    #include &lt;cstring>\n    #include &lt;vector>\n    #include &lt;queue>\n    #include &lt;algorithm>\n    #include &lt;map>\n    #include &lt;stack>\n    #include &lt;ctype.h>\n    #include &lt;iostream>\n    using namespace std;\n    int  in[50], la[50];\n    int n;\n    vector&lt;int> layervec, prevec, postvec;\n    struct node{\n        int data,layer;\n        node *left, *right;\n        node(node *_left = NULL, node *_right = NULL ){\n            left = _left;//初始化\n            right = _right;//初始化\n        }\n    };\n    node* createTree(vector&lt;int> layer, int inL, int inR){\n        if (layer.size() == 0) {//层次遍历为空，返回空地址\n            return NULL;\n        }\n        node* root = new node;\n        root->data = layer[0];//层次向量中第一个为根节点\n        int k;\n        for (k = inL; k &lt;= inR; k++) {\n            if (layer[0] == in[k]) {//在中序遍历中找到根节点\n                break;\n            }\n        }\n        vector&lt;int> layerLeft;\n        vector&lt;int> layerRight;\n        for (int i = 1; i &lt; layer.size(); i++) {//在层次向量中枚举根节点左侧\n            bool isLeft = false;\n            for (int j = inL; j &lt; k; j++) {\n                if (layer[i] == in[j]) {\n                    isLeft = true;\n                }\n            }\n            if (isLeft) {//找到一个按顺序放入，顺序在前的为根节点\n                layerLeft.push_back(layer[i]);\n            }else{\n                layerRight.push_back(layer[i]);\n            }\n        }\n        root->left = createTree(layerLeft, inL, k - 1);\n        root->right = createTree(layerRight, k + 1, inR);\n        return root;\n    }\n    void preOrder(node *root, vector&lt;int> &amp;vi){\n        if (root == NULL) {\n            return;\n        }\n        vi.push_back(root->data);\n        preOrder(root->left, vi);\n        preOrder(root->right, vi);\n    }\n    void postOrder(node *root, vector&lt;int> &amp;vi){\n        if (root == NULL) {\n            return;\n        }\n        postOrder(root->left, vi);\n        postOrder(root->right, vi);\n        vi.push_back(root->data);\n    }\n    int maxlep = 0;\n    void dfs(node* root, int ldep){\n        maxlep = max(maxlep, ldep);\n        if (root == NULL) {\n            return;\n        }\n        if(root->left)dfs(root->left, ldep);\n        if(root->right)dfs(root->right, ldep + 1);\n        return;\n    }\n    int minleaf = 0, maxleaf = 0;\n    void dfs1(node* root, int ldep){\n        minleaf = min(minleaf, ldep);\n        maxleaf = max(maxleaf, ldep);\n        if (root == NULL) {\n            return;\n        }\n        if(root->left)dfs1(root->left, ldep - 1);\n        if(root->right)dfs1(root->right, ldep + 1);\n        return;\n    }\n    int layerOrder(node*root){//返回层数\n        queue&lt;node*> q;\n        q.push(root);\n        root->layer = 1;\n        int maxlayer = 0;\n        while (!q.empty()) {\n            node* now = q.front();\n            q.pop();\n            maxlayer = max(now->layer, maxlayer);\n            if (now->left != NULL) {\n                now->left->layer = now->layer + 1;\n                q.push(now->left);\n            }\n            if (now->right != NULL) {\n                now->right->layer = now->layer + 1;\n                q.push(now->right);\n            }\n    \n        }\n        return maxlayer;\n    }\n    int main(){\n        scanf(\"%d\", &amp;n);\n        for (int i = 0; i &lt; n; i++) {//layer\n            scanf(\"%d\", &amp;la[i]);\n            layervec.push_back(la[i]);//入向量\n        }\n        for (int i = 0; i &lt; n; i++) {//in\n            scanf(\"%d\", &amp;in[i]);\n        }\n        node *root = new node;\n        root = createTree(layervec, 0, n - 1);\n        preOrder(root,prevec);\n        postOrder(root,postvec);\n        for (int i = 0; i &lt; n; i++) {\n            printf(\"%d\",prevec[i]);\n            if (i &lt; n - 1) {\n                printf(\" \");\n            }else printf(\"\\n\");\n        }\n        for (int i = 0; i &lt; n; i++) {\n            printf(\"%d\",postvec[i]);\n            if (i &lt; n - 1) {\n                printf(\" \");\n            }else printf(\"\\n\");\n        }\n        dfs(root, 0);//从右上往左下看\n        dfs1(root, 0);//从上往下看\n        printf(\"%d\\n\", layerOrder(root));\n        printf(\"%d\\n\", maxlep + 1);\n        printf(\"%d\\n\", abs(minleaf) + maxleaf + 1);\n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"3.1模拟题 problem4 上帝视角","date":"March 02, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/252/"},"frontmatter":{"title":"3.1模拟题 problem2 万妖穴"}},"next":{"fields":{"slug":"/old-posts/255/"},"frontmatter":{"title":"PAT重点整理——二叉树生成"}}},"pageContext":{"id":"bd195b5f-9807-5ee1-9d29-4cd06b6c0cf6","previousPostId":"9664c564-3e9c-53d7-9de7-e4a1e50d6490","nextPostId":"ace8c666-9af7-5c72-bb68-8a481839de04"}},
    "staticQueryHashes": ["2841359383","3257411868"]}