{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/155/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"fdc75508-7885-5c2f-90fa-5c604702d509","excerpt":"Given any positive integer N, you are supposed to find all of its prime factors, and write them in the format N = p1^k1 * p2^k2 *…*pm^km. Input Specification…","html":"<p>Given any positive integer N, you are supposed to find all of its prime factors, and write them in the format N = p1^k1 * p2^k2 *…*pm^km.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case which gives a positive integer N in the range of long int.</p>\n<p>Output Specification:</p>\n<p>Factor N in the format N = p1^k1 * p2^k2 *…*pm^km, where pi’s are prime factors of N in increasing order, and the exponent ki is the number of pi — hence when there is only one pi, ki is 1 and must NOT be printed out.</p>\n<p>Sample Input:\n97532468\nSample Output:\n97532468=2^2<em>11</em>17<em>101</em>1291</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    #include \"algorithm\"\n    #include \"string.h\"\n    using namespace std;\n    const int maxn = 1000001;\n    int prime[maxn], pnum = 0;\n    bool p[maxn] = {0};\n    void Find_Prime(int n) {//筛法出素数表\n    \tfor (int i = 2; i &lt; maxn; i++) {\n    \t\tif(p[i] == false){\n    \t\t\tprime[pnum++] = i;\n    \t\t\tif(pnum >= n)break;//只要n个素数\n    \t\t\tfor(int j = i + i ; j &lt; maxn; j += i){\n    \t\t\t\tp[j] = true;\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    struct factor{\n    \tint x,cnt;\n    }fac[10];\n    int main(){\n    \tFind_Prime(100010);\n    \tint n, num = 0;//num 为n的不同质因子的个数\n    \tscanf(\"%d\", &amp;n);\n    \tif(n == 1) printf(\"1=1\");\n    \telse {\n    \t\tprintf(\"%d=\", n);\n    \t\tint sqr = (int)sqrt(1.0 * n);//n的根号\n    \t\tfor (int i = 0;i &lt; pnum &amp;&amp; prime[i] &lt;= sqr;i++){//枚举sqr以内的质数\n    \t\t\tif(n % prime[i] == 0){\n    \t\t\t\tfac[num].x = prime[i];//记录该因子\n    \t\t\t\tfac[num].cnt = 0;\n    \t\t\t\twhile(n % prime[i] == 0){\n    \t\t\t\t\tfac[num].cnt++;\n    \t\t\t\t\tn /= prime[i];\n    \t\t\t\t}\n    \t\t\t\tnum++;\n    \t\t\t}\n    \t\t\tif(n == 1) break;\n    \t\t}\n    \t\tif(n != 1){//如果无法被根号n以内的质因子除尽\n    \t\t\tfac[num].x = n;//那么一定有一个大于根号n的质因子\n    \t\t\tfac[num++].cnt = 1;\n    \t\t}\n    \t\t//按格式输出结果\n    \t\tfor (int i = 0; i &lt; num; i++){\n    \t\t\tif(i > 0) printf(\"*\");\n    \t\t\tprintf(\"%d\", fac[i].x);\n    \t\t\tif(fac[i].cnt >1){\n    \t\t\t\tprintf(\"^%d\",fac[i].cnt);\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn 0;\n    }</code></pre></div>\n<p>感想：筛法出素数表真的吊……没数学头脑的我只能看看了……\n再弄记录一个常规的出素数表的方法</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    const int maxn = 1000001;\n    int prime[maxn], pnum = 0;\n\n    bool is_prime(int n){//判断n是否为素数\n    \tif(n == 1) return false;\n    \tint sqr = (int)sqrt(1.0 * n);\n    \tfor (int i = 2; i &lt;= sqr ; i++){\n    \t\tif(n % i == 0) return false;\n    \t}\n    \treturn true;\n    }\n    int p[maxn], pnum = 0;\n    void Find_Prime(){//打印素数表\n    \tfor(int i = 1; i &lt; maxn; i++){\n    \t\tif(is_prime(i) == true)\n    \t\t\tprime[pnum++] = i;\n    \t}\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1059","date":"February 13, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/154/"},"frontmatter":{"title":"PAT B1013"}},"next":{"fields":{"slug":"/old-posts/156/"},"frontmatter":{"title":"大整数四则运算"}}},"pageContext":{"id":"fdc75508-7885-5c2f-90fa-5c604702d509","previousPostId":"42f9db99-0466-53d0-877d-4a2d63d01d67","nextPostId":"eb896522-115b-56ff-8064-625ef29d06d6"}},
    "staticQueryHashes": ["2841359383","3257411868"]}