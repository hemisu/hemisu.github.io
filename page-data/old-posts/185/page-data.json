{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/old-posts/185/",
    "result": {"data":{"site":{"siteMetadata":{"title":"何米酥`s Blog"}},"markdownRemark":{"id":"9fdce037-5606-5940-9c7b-f3e9c59918d8","excerpt":"Behind the scenes in the computer’s memory, color is always talked about as a series of 24 bits of information for each pixel. In an image, the color with the…","html":"<p>Behind the scenes in the computer’s memory, color is always talked about as a series of 24 bits of information for each pixel. In an image, the color with the largest proportional area is called the dominant color. A strictly dominant color takes more than half of the total area. Now given an image of resolution M by N (for example, 800x600), you are supposed to point out the strictly dominant color.</p>\n<p>Input Specification:</p>\n<p>Each input file contains one test case. For each case, the first line contains 2 positive numbers: M (&#x3C;=800) and N (&#x3C;=600) which are the resolutions of the image. Then N lines follow, each contains M digital colors in the range [0, 224). It is guaranteed that the strictly dominant color exists for each input image. All the numbers in a line are separated by a space.</p>\n<p>Output Specification:</p>\n<p>For each test case, simply print the dominant color in a line.</p>\n<p>Sample Input:\n5 3\n0 0 255 16777215 24\n24 24 0 0 24\n24 0 24 24 24\nSample Output:\n24</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    #include \"stdio.h\"\n    //#include \"math.h\"\n    #include \"string.h\"\n    #include \"iostream\"\n    //#include \"stdlib.h\"\n    #include \"algorithm\"\n    //#include \"vector\"\n    //#include \"set\"\n    #include \"map\"\n    using namespace std;\n    //typedef long long LL;\n    \n    \n    int main(){\n        int n, m, col;\n        scanf(\"%d%d\", &amp;n, &amp;m);//行与列\n        map&lt;int, int> count;\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 0; j &lt; m; j++) {\n                scanf(\"%d\", &amp;col);//输入数字\n                if (count.find(col) != count.end()) {\n                    count[col]++;//若已存在，则次数+1\n                }else{\n                    count[col] = 1;//若不存在，次数为1\n                }\n            }\n        }\n        int k = 0, Max = 0;//最大的数字及该数字出现的次数\n        for (map&lt;int,int>::iterator it = count.begin(); it != count.end(); it++) {\n            if (it->second > Max) {\n                Max = it -> second;\n                k = it -> first;\n            }\n        }\n        printf(\"%d\\n\", k);\n        return 0;\n    }</code></pre></div>","tableOfContents":"","frontmatter":{"title":"PAT A1054","date":"February 20, 2017","description":null}},"previous":{"fields":{"slug":"/old-posts/184/"},"frontmatter":{"title":"PAT B1044/A1100"}},"next":{"fields":{"slug":"/old-posts/186/"},"frontmatter":{"title":"PAT A1071"}}},"pageContext":{"id":"9fdce037-5606-5940-9c7b-f3e9c59918d8","previousPostId":"01e5e4fa-1a0a-5926-9cf7-06fbf1147fe4","nextPostId":"754ecd91-4401-5d4b-9aa5-1a5fcb5af3c1"}},
    "staticQueryHashes": ["2841359383","3257411868"]}